<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/img/favicon.ico">
    
    
        <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
    
    


    <!-- meta -->


<title>Java常见面试题 | ZYang&#39;s Blog</title>


    <meta name="keywords" content="java, 面试题, 博客,blog,Java">




    <!-- OpenGraph -->
 
    <meta name="description" content="Java 基础1、谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分">
<meta property="og:type" content="article">
<meta property="og:title" content="Java常见面试题">
<meta property="og:url" content="https://luziyangde.cn/2021/03/10/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="ZYang&#39;s Blog">
<meta property="og:description" content="Java 基础1、谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“书写一次，到处运行”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是垃圾收集（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210310210018.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/360b8f453e016cb641208a6a8fb589bc.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/3a51f06f56b905b8fbf1661359e1727e.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/ffd41494a39ef737b3c1151929c3c4ad.png">
<meta property="article:published_time" content="2021-03-10T14:05:00.000Z">
<meta property="article:modified_time" content="2022-12-04T03:23:00.000Z">
<meta property="article:author" content="ZYang">
<meta property="article:tag" content="java">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://image.luziyangde.cn//img/20210310210018.png">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/tomorrow.css" media="none" >
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/tomorrow-night.css" media="none">
        
    

    
    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 6.3.0"></head>

    <body>
        <div id="app" tabindex="-1">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">ZYang&#39;s Blog</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        Java常见面试题
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2021/03/" class="post-meta__date button">2021-03-10 22:05</a>
        
 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Java-%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E2%80%9CJava-%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E2%80%9D%EF%BC%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1、谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AF%B7%E5%AF%B9%E6%AF%94-Exception-%E5%92%8C-Error%EF%BC%8C%E5%8F%A6%E5%A4%96%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2、请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%B0%88%E8%B0%88-final%E3%80%81finally%E3%80%81-finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3、谈谈 final、finally、 finalize 有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4、强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%90%86%E8%A7%A3-Java-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8CString%E3%80%81StringBuffer%E3%80%81StringBuilder-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5、理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%B0%88%E8%B0%88-Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6、谈谈 Java 反射机制，动态代理是基于什么原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%B0%88%E8%B0%88-Integer-%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4%E3%80%82"><span class="toc-number">1.7.</span> <span class="toc-text">7、int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%AF%B9%E6%AF%94-Vector%E3%80%81ArrayList%E3%80%81LinkedList-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">8、对比 Vector、ArrayList、LinkedList 有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%AF%B9%E6%AF%94-Hashtable%E3%80%81HashMap%E3%80%81TreeMap-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-HashMap-%E7%9A%84%E6%8E%8C%E6%8F%A1%E3%80%82"><span class="toc-number">1.9.</span> <span class="toc-text">9、对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%B9%E5%99%A8%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9FConcurrentHashMap-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10、如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81Java-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B-IO-%E6%96%B9%E5%BC%8F%EF%BC%9F-NIO-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">11、Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81Java-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E4%B8%80%E7%A7%8D%E6%9C%80%E9%AB%98%E6%95%88%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12、Java 有几种文件拷贝方式？哪一种最高效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13、谈谈接口和抽象类有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E8%AF%B7%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8CSpring-%E7%AD%89%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">14、谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">Java 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9C%89%E4%BA%BA%E8%AF%B4-synchronized-%E6%9C%80%E6%85%A2%EF%BC%8C%E8%BF%99%E8%AF%9D%E9%9D%A0%E8%B0%B1%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">15、synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81synchronized-%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E3%80%81%E9%99%8D%E7%BA%A7%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">16、synchronized 底层如何实现？什么是锁的升级、降级？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F%E8%B0%88%E8%B0%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E3%80%82"><span class="toc-number">2.3.</span> <span class="toc-text">17、一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B-Java-%E7%A8%8B%E5%BA%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E3%80%81%E4%BF%AE%E5%A4%8D%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">18、什么情况下 Java 程序会产生死锁？如何定位、修复？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81Java-%E5%B9%B6%E5%8F%91%E5%8C%85%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">19、Java 并发包提供了哪些并发工具类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84-ConcurrentLinkedQueue-%E5%92%8C-LinkedBlockingQueue-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">20、并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81Java-%E5%B9%B6%E5%8F%91%E7%B1%BB%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F-%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">21、Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81AtomicInteger-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%BA%94%E7%94%A8-CAS-%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">22、AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81%E8%AF%B7%E4%BB%8B%E7%BB%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">23、请介绍类加载过程，什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA-Java-%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">24、有哪些方法可以在运行时动态生成一个 Java 类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81%E8%B0%88%E8%B0%88-JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F-OutOfMemoryError%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">25、谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E8%AF%8A%E6%96%AD-JVM-%E5%A0%86%E5%86%85%E5%92%8C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">26、如何监控和诊断 JVM 堆内和堆外内存使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81Java-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">27、Java 常见的垃圾收集器有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84-GC-%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">28、谈谈你的 GC 调优思路？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84-happen-before-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">29、Java 内存模型中的 happen-before 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81Java-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8-Docker-%E7%AD%89%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">30、Java 程序运行在 Docker 等容器环境有哪些新问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">Java安全基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">31、你了解 Java 应用开发中的注入攻击吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%AE%89%E5%85%A8%E7%9A%84-Java-%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">32、如何写出安全的 Java 代码？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">Java性能基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E6%98%8E%E6%98%BE%E2%80%9C%E5%8F%98%E6%85%A2%E2%80%9D%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">33、后台服务出现明显“变慢”，谈谈你的诊断思路？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E3%80%81%E6%9C%89%E4%BA%BA%E8%AF%B4%E2%80%9CLambda-%E8%83%BD%E8%AE%A9-Java-%E7%A8%8B%E5%BA%8F%E6%85%A2-30-%E5%80%8D%E2%80%9D%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">34、有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81JVM-%E4%BC%98%E5%8C%96-Java-%E4%BB%A3%E7%A0%81%E6%97%B6%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">35、JVM 优化 Java 代码时都做了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%89%A9%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">Java应用开发扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81%E8%B0%88%E8%B0%88-MySQL-%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">36、谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37%E3%80%81%E8%B0%88%E8%B0%88-Spring-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">37、谈谈 Spring Bean 的生命周期和作用域？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38%E3%80%81%E5%AF%B9%E6%AF%94-Java-%E6%A0%87%E5%87%86-NIO-%E7%B1%BB%E5%BA%93%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93-Netty-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9B%B4%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">38、对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39%E3%80%81%E8%B0%88%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-ID-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%EF%BC%9FSnowflake-%E6%98%AF%E5%90%A6%E5%8F%97%E5%86%AC%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">39、谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Java 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-Java-%E5%B9%B3%E5%8F%B0%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F%E2%80%9CJava-%E6%98%AF%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E2%80%9D%EF%BC%8C%E8%BF%99%E5%8F%A5%E8%AF%9D%E6%AD%A3%E7%A1%AE%E5%90%97%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">1、谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AF%B7%E5%AF%B9%E6%AF%94-Exception-%E5%92%8C-Error%EF%BC%8C%E5%8F%A6%E5%A4%96%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E4%B8%8E%E4%B8%80%E8%88%AC%E5%BC%82%E5%B8%B8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">2、请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E8%B0%88%E8%B0%88-final%E3%80%81finally%E3%80%81-finalize-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">3、谈谈 final、finally、 finalize 有什么不同？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E5%B9%BB%E8%B1%A1%E5%BC%95%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">4、强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81%E7%90%86%E8%A7%A3-Java-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8CString%E3%80%81StringBuffer%E3%80%81StringBuilder-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">5、理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81%E8%B0%88%E8%B0%88-Java-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6、谈谈 Java 反射机制，动态代理是基于什么原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81int-%E5%92%8C-Integer-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E8%B0%88%E8%B0%88-Integer-%E7%9A%84%E5%80%BC%E7%BC%93%E5%AD%98%E8%8C%83%E5%9B%B4%E3%80%82"><span class="toc-number">1.7.</span> <span class="toc-text">7、int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E5%AF%B9%E6%AF%94-Vector%E3%80%81ArrayList%E3%80%81LinkedList-%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">8、对比 Vector、ArrayList、LinkedList 有何区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E5%AF%B9%E6%AF%94-Hashtable%E3%80%81HashMap%E3%80%81TreeMap-%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9-HashMap-%E7%9A%84%E6%8E%8C%E6%8F%A1%E3%80%82"><span class="toc-number">1.9.</span> <span class="toc-text">9、对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%AE%B9%E5%99%A8%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9FConcurrentHashMap-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%9C%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10、如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81Java-%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B-IO-%E6%96%B9%E5%BC%8F%EF%BC%9F-NIO-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">11、Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12%E3%80%81Java-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%87%E4%BB%B6%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F%EF%BC%9F%E5%93%AA%E4%B8%80%E7%A7%8D%E6%9C%80%E9%AB%98%E6%95%88%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">12、Java 有几种文件拷贝方式？哪一种最高效？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13%E3%80%81%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">13、谈谈接口和抽象类有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F%E8%AF%B7%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%8CSpring-%E7%AD%89%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">14、谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E8%BF%9B%E9%98%B6"><span class="toc-number">2.</span> <span class="toc-text">Java 进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15%E3%80%81synchronized-%E5%92%8C-ReentrantLock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%9C%89%E4%BA%BA%E8%AF%B4-synchronized-%E6%9C%80%E6%85%A2%EF%BC%8C%E8%BF%99%E8%AF%9D%E9%9D%A0%E8%B0%B1%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">15、synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16%E3%80%81synchronized-%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E3%80%81%E9%99%8D%E7%BA%A7%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">16、synchronized 底层如何实现？什么是锁的升级、降级？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17%E3%80%81%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%A4%E6%AC%A1%E8%B0%83%E7%94%A8-start-%E6%96%B9%E6%B3%95%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F%E8%B0%88%E8%B0%88%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E3%80%82"><span class="toc-number">2.3.</span> <span class="toc-text">17、一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B-Java-%E7%A8%8B%E5%BA%8F%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E3%80%81%E4%BF%AE%E5%A4%8D%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">18、什么情况下 Java 程序会产生死锁？如何定位、修复？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19%E3%80%81Java-%E5%B9%B6%E5%8F%91%E5%8C%85%E6%8F%90%E4%BE%9B%E4%BA%86%E5%93%AA%E4%BA%9B%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">19、Java 并发包提供了哪些并发工具类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20%E3%80%81%E5%B9%B6%E5%8F%91%E5%8C%85%E4%B8%AD%E7%9A%84-ConcurrentLinkedQueue-%E5%92%8C-LinkedBlockingQueue-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">20、并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21%E3%80%81Java-%E5%B9%B6%E5%8F%91%E7%B1%BB%E5%BA%93%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F-%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">21、Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22%E3%80%81AtomicInteger-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%9C%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%A7%E5%93%81%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%BA%94%E7%94%A8-CAS-%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">22、AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23%E3%80%81%E8%AF%B7%E4%BB%8B%E7%BB%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">23、请介绍类加载过程，什么是双亲委派模型？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24%E3%80%81%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E4%B8%80%E4%B8%AA-Java-%E7%B1%BB%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">24、有哪些方法可以在运行时动态生成一个 Java 类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25%E3%80%81%E8%B0%88%E8%B0%88-JVM-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%88%92%E5%88%86%EF%BC%8C%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%9F%9F%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F-OutOfMemoryError%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">25、谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26%E3%80%81%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%E5%92%8C%E8%AF%8A%E6%96%AD-JVM-%E5%A0%86%E5%86%85%E5%92%8C%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">26、如何监控和诊断 JVM 堆内和堆外内存使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27%E3%80%81Java-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">27、Java 常见的垃圾收集器有哪些？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84-GC-%E8%B0%83%E4%BC%98%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">28、谈谈你的 GC 调优思路？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#29%E3%80%81Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84-happen-before-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">29、Java 内存模型中的 happen-before 是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#30%E3%80%81Java-%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9C%A8-Docker-%E7%AD%89%E5%AE%B9%E5%99%A8%E7%8E%AF%E5%A2%83%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">30、Java 程序运行在 Docker 等容器环境有哪些新问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">Java安全基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31%E3%80%81%E4%BD%A0%E4%BA%86%E8%A7%A3-Java-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%90%97%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">31、你了解 Java 应用开发中的注入攻击吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32%E3%80%81%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%AE%89%E5%85%A8%E7%9A%84-Java-%E4%BB%A3%E7%A0%81%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">32、如何写出安全的 Java 代码？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E6%80%A7%E8%83%BD%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">Java性能基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#33%E3%80%81%E5%90%8E%E5%8F%B0%E6%9C%8D%E5%8A%A1%E5%87%BA%E7%8E%B0%E6%98%8E%E6%98%BE%E2%80%9C%E5%8F%98%E6%85%A2%E2%80%9D%EF%BC%8C%E8%B0%88%E8%B0%88%E4%BD%A0%E7%9A%84%E8%AF%8A%E6%96%AD%E6%80%9D%E8%B7%AF%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">33、后台服务出现明显“变慢”，谈谈你的诊断思路？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34%E3%80%81%E6%9C%89%E4%BA%BA%E8%AF%B4%E2%80%9CLambda-%E8%83%BD%E8%AE%A9-Java-%E7%A8%8B%E5%BA%8F%E6%85%A2-30-%E5%80%8D%E2%80%9D%EF%BC%8C%E4%BD%A0%E6%80%8E%E4%B9%88%E7%9C%8B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">34、有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35%E3%80%81JVM-%E4%BC%98%E5%8C%96-Java-%E4%BB%A3%E7%A0%81%E6%97%B6%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">35、JVM 优化 Java 代码时都做了什么？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E6%89%A9%E5%B1%95"><span class="toc-number">5.</span> <span class="toc-text">Java应用开发扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#36%E3%80%81%E8%B0%88%E8%B0%88-MySQL-%E6%94%AF%E6%8C%81%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">36、谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37%E3%80%81%E8%B0%88%E8%B0%88-Spring-Bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">37、谈谈 Spring Bean 的生命周期和作用域？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38%E3%80%81%E5%AF%B9%E6%AF%94-Java-%E6%A0%87%E5%87%86-NIO-%E7%B1%BB%E5%BA%93%EF%BC%8C%E4%BD%A0%E7%9F%A5%E9%81%93-Netty-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%9B%B4%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">38、对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39%E3%80%81%E8%B0%88%E8%B0%88%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F-ID-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88%EF%BC%9FSnowflake-%E6%98%AF%E5%90%A6%E5%8F%97%E5%86%AC%E4%BB%A4%E6%97%B6%E5%88%87%E6%8D%A2%E5%BD%B1%E5%93%8D%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">39、谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header">
    <div class="post__expire" id="post-expired-notify">
        <p>
            本文最后更新于 &lt;span id=&#34;expire-date&#34;&gt;&lt;/span&gt; 天前，文中部分描述可能已经过时。
        </p>
    </div>
    <script>
        (() => {
            var update = Date.parse("2022-12-04"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();
    </script>
</div>
    <div class="post__content">
        <h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><h4 id="1、谈谈你对-Java-平台的理解？“Java-是解释执行”，这句话正确吗？"><a href="#1、谈谈你对-Java-平台的理解？“Java-是解释执行”，这句话正确吗？" class="headerlink" title="1、谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？"></a>1、谈谈你对 Java 平台的理解？“Java 是解释执行”，这句话正确吗？</h4><p>Java 本身是一种面向对象的语言，最显著的特性有两个方面，一是所谓的“<strong>书写一次，到处运行</strong>”（Write once, run anywhere），能够非常容易地获得跨平台能力；另外就是<strong>垃圾收集</strong>（GC, Garbage Collection），Java 通过垃圾收集器（Garbage Collector）回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</p>
<p>我们日常会接触到 JRE（Java Runtime Environment）或者 JDK（Java Development Kit）。 JRE，也就是 Java 运行环境，包含了 JVM 和 Java 类库，以及一些模块等。而 JDK 可以看作是 JRE 的一个超集，提供了更多工具，比如编译器、各种诊断工具等。</p>
<p>对于“Java 是解释执行”这句话，这个说法不太准确。我们开发的 Java 的源代码，首先通过 Javac 编译成为字节码（bytecode），然后，在运行时，通过 Java 虚拟机（JVM）内嵌的解释器将字节码转换成为最终的机器码。但是常见的 JVM，比如我们大多数情况使用的 Oracle JDK 提供的 Hotspot JVM，都提供了 JIT（Just-In-Time）编译器，也就是通常所说的动态编译器，JIT 能够在运行时将热点代码编译成机器码，这种情况下部分热点代码就属于<strong>编译执行</strong>，而不是解释执行了。</p>
<hr>
<h4 id="2、请对比-Exception-和-Error，另外，运行时异常与一般异常有什么区别？"><a href="#2、请对比-Exception-和-Error，另外，运行时异常与一般异常有什么区别？" class="headerlink" title="2、请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？"></a>2、请对比 Exception 和 Error，另外，运行时异常与一般异常有什么区别？</h4><p>Exception 和 Error 都是继承了 Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。</p>
<p>Exception 和 Error 体现了 Java 平台设计者对不同异常情况的分类。Exception 是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应处理。</p>
<p>Error 是指在正常情况下，不大可能出现的情况，绝大部分的 Error 都会导致程序（比如 JVM 自身）处于非正常的、不可恢复状态。既然是非正常情况，所以不便于也不需要捕获，常见的比如 OutOfMemoryError 之类，都是 Error 的子类。</p>
<p>Exception 又分为<strong>可检查</strong>（checked）异常和<strong>不检查</strong>（unchecked）异常，可检查异常在源代码里必须显式地进行捕获处理，这是编译期检查的一部分。前面我介绍的不可查的 Error，是 Throwable 不是 Exception。</p>
<p>不检查异常就是所谓的运行时异常，类似 NullPointerException、ArrayIndexOutOfBoundsException 之类，通常是可以编码避免的逻辑错误，具体根据需要来判断是否需要捕获，并不会在编译期强制要求。</p>
<hr>
<h4 id="3、谈谈-final、finally、-finalize-有什么不同？"><a href="#3、谈谈-final、finally、-finalize-有什么不同？" class="headerlink" title="3、谈谈 final、finally、 finalize 有什么不同？"></a>3、谈谈 final、finally、 finalize 有什么不同？</h4><p><strong>final</strong> 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。</p>
<p><strong>finally</strong> 则是 Java 保证重点代码一定要被执行的一种机制。我们可以使用 try-finally 或者 try-catch-finally 来进行类似关闭 JDBC 连接、保证 unlock 锁等动作。</p>
<p><strong>finalize</strong> 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在 JDK 9 开始被标记为 deprecated。</p>
<hr>
<h4 id="4、强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？"><a href="#4、强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？" class="headerlink" title="4、强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？"></a>4、强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</h4><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响</strong>。</p>
<p>所谓<strong>强引用</strong>（“Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p>
<p><strong>软引用</strong>（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p><strong>弱引用</strong>（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p>
<p>对于<strong>幻象引用</strong>，有时候也翻译成<strong>虚引用</strong>，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。</p>
<hr>
<h4 id="5、理解-Java-的字符串，String、StringBuffer、StringBuilder-有什么区别？"><a href="#5、理解-Java-的字符串，String、StringBuffer、StringBuilder-有什么区别？" class="headerlink" title="5、理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？"></a>5、理解 Java 的字符串，String、StringBuffer、StringBuilder 有什么区别？</h4><p><strong>String</strong> 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。</p>
<p><strong>StringBuffer</strong> 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer 本质是一个<strong>线程安全</strong>的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用它的后继者，也就是 StringBuilder。</p>
<p><strong>StringBuilder</strong> 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。</p>
<hr>
<h4 id="6、谈谈-Java-反射机制，动态代理是基于什么原理？"><a href="#6、谈谈-Java-反射机制，动态代理是基于什么原理？" class="headerlink" title="6、谈谈 Java 反射机制，动态代理是基于什么原理？"></a>6、谈谈 Java 反射机制，动态代理是基于什么原理？</h4><p>反射机制是 Java 语言提供的一种基础功能，赋予程序在运行时<strong>自省</strong>（introspect，官方用语）的能力。通过反射我们可以直接操作类或者对象，比如获取某个对象的类定义，获取类声明的属性和方法，调用方法或者构造对象，甚至可以运行时修改类定义。</p>
<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。</p>
<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>
<hr>
<h4 id="7、int-和-Integer-有什么区别？谈谈-Integer-的值缓存范围。"><a href="#7、int-和-Integer-有什么区别？谈谈-Integer-的值缓存范围。" class="headerlink" title="7、int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。"></a>7、int 和 Integer 有什么区别？谈谈 Integer 的值缓存范围。</h4><p><strong>int</strong> 是我们常说的整形数字，是 Java 的 8 个原始数据类型（Primitive Types，boolean、byte 、short、char、int、float、double、long）之一。<strong>Java 语言虽然号称一切都是对象，但原始数据类型是例外。</strong></p>
<p><strong>Integer</strong> 是 int 对应的<strong>包装类</strong>，它有一个 int 类型的字段存储数据，并且提供了基本操作，比如数学运算、int 和字符串之间转换等。在 Java 5 中，引入了<strong>自动装箱</strong>和<strong>自动拆箱</strong>功能（boxing&#x2F;unboxing），Java 可以根据上下文，自动进行转换，极大地简化了相关编程。</p>
<p>关于 Integer 的值<strong>缓存</strong>，这涉及 Java 5 中另一个改进。构建 Integer 对象的传统方式是直接调用构造器，直接 new 一个对象。但是根据实践，我们发现大部分数据操作都是集中在有限的、较小的数值范围，因而，在 Java 5 中新增了<strong>静态工厂方法 valueOf</strong>，在调用它的时候会利用一个缓存机制，带来了明显的性能改进。按照 Javadoc，<strong>这个值默认缓存是 -128 到 127 之间</strong>。</p>
<hr>
<h4 id="8、对比-Vector、ArrayList、LinkedList-有何区别？"><a href="#8、对比-Vector、ArrayList、LinkedList-有何区别？" class="headerlink" title="8、对比 Vector、ArrayList、LinkedList 有何区别？"></a>8、对比 Vector、ArrayList、LinkedList 有何区别？</h4><p>这三者都是实现集合框架中的 List，也就是所谓的<strong>有序集合</strong>，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。</p>
<p><strong>Vector</strong> 是 Java 早期提供的<strong>线程安全</strong>的<strong>动态数组</strong>，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。</p>
<p><strong>ArrayList</strong> 是应用更加广泛的<strong>动态数组</strong>实现，它本身<strong>不是线程安全的</strong>，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。</p>
<p><strong>LinkedList</strong> 顾名思义是 Java 提供的<strong>双向链表</strong>，所以它不需要像上面两种那样调整容量，它也<strong>不是线程安全的</strong>。</p>
<hr>
<h4 id="9、对比-Hashtable、HashMap、TreeMap-有什么不同？谈谈你对-HashMap-的掌握。"><a href="#9、对比-Hashtable、HashMap、TreeMap-有什么不同？谈谈你对-HashMap-的掌握。" class="headerlink" title="9、对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握。"></a>9、对比 Hashtable、HashMap、TreeMap 有什么不同？谈谈你对 HashMap 的掌握。</h4><p>Hashtable、HashMap、TreeMap 都是最常见的一些 Map 实现，是以<strong>键值对</strong>的形式存储和操作数据的容器类型。</p>
<p><strong>Hashtable</strong> 是早期 Java 类库提供的一个<strong>哈希表</strong>实现，本身是<strong>同步的</strong>，<strong>不支持 null 键和值</strong>，由于同步导致的性能开销，所以已经很少被推荐使用。</p>
<p><strong>HashMap</strong> 是应用更加广泛的<strong>哈希表</strong>实现，行为上大致上与 HashTable 一致，主要区别在于 HashMap <strong>不是同步的</strong>，<strong>支持 null 键和值</strong>等。通常情况下，HashMap 进行 put 或者 get 操作，可以达到常数时间的性能，所以<strong>它是绝大部分利用键值对存取场景的首选</strong>，比如，实现一个用户 ID 和用户信息对应的运行时存储结构。</p>
<p><strong>TreeMap</strong> 则是基于<strong>红黑树</strong>的一种提供顺序访问的 Map，和 HashMap 不同，它的 get、put、remove 之类操作都是 O（log(n)）的时间复杂度，具体顺序可以由指定的 Comparator 来决定，或者根据键的自然顺序来判断。</p>
<hr>
<h4 id="10、如何保证容器是线程安全的？ConcurrentHashMap-如何实现高效地线程安全？"><a href="#10、如何保证容器是线程安全的？ConcurrentHashMap-如何实现高效地线程安全？" class="headerlink" title="10、如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？"></a>10、如何保证容器是线程安全的？ConcurrentHashMap 如何实现高效地线程安全？</h4><p>Java 提供了不同层面的线程安全支持。在传统集合框架内部，除了 Hashtable 等同步容器，还提供了所谓的同步包装器（Synchronized Wrapper），我们可以调用 Collections 工具类提供的包装方法，来获取一个同步的包装容器（如 Collections.synchronizedMap），但是它们都是利用非常粗粒度的同步方式，在高并发情况下，性能比较低下。</p>
<p>另外，更加普遍的选择是利用并发包提供的线程安全容器类，它提供了：</p>
<ul>
<li>各种<strong>并发容器</strong>，比如 ConcurrentHashMap、CopyOnWriteArrayList。</li>
<li>各种<strong>线程安全队列</strong>（Queue&#x2F;Deque），如 ArrayBlockingQueue、SynchronousQueue。</li>
<li>各种<strong>有序容器</strong>的线程安全版本等。</li>
</ul>
<p>具体保证线程安全的方式，包括有从简单的 synchronize 方式，到基于更加精细化的，比如基于分离锁实现的 ConcurrentHashMap 等并发实现等。具体选择要看开发的场景需求，总体来说，并发包内提供的容器通用场景，远优于早期的简单同步实现。</p>
<hr>
<h4 id="11、Java-提供了哪些-IO-方式？-NIO-如何实现多路复用？"><a href="#11、Java-提供了哪些-IO-方式？-NIO-如何实现多路复用？" class="headerlink" title="11、Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？"></a>11、Java 提供了哪些 IO 方式？ NIO 如何实现多路复用？</h4><p>Java IO 方式有很多种，基于不同的 IO 抽象模型和交互方式，可以进行简单区分。</p>
<p>第一，传统的 <strong>java.io 包</strong>，它基于<strong>流模型</strong>实现，提供了我们最熟知的一些 IO 功能，比如 File 抽象、输入输出流等。交互方式是<strong>同步、阻塞</strong>的方式，也就是说，在读取输入流或者写入输出流时，在读、写动作完成之前，线程会一直阻塞在那里，它们之间的调用是可靠的线性顺序。</p>
<p>java.io 包的好处是代码比较简单、直观，缺点则是 IO 效率和扩展性存在局限性，容易成为应用性能的瓶颈。</p>
<p>很多时候，人们也把 java.net 下面提供的部分网络 API，比如 Socket、ServerSocket、HttpURLConnection 也归类到同步阻塞 IO 类库，因为网络通信同样是 IO 行为。</p>
<p>第二，在 Java 1.4 中引入了 <strong>NIO 框架</strong>（<strong>java.nio 包</strong>），提供了 Channel、Selector、Buffer 等新的抽象，可以构建<strong>多路复用的、同步非阻塞</strong> IO 程序，同时提供了更接近操作系统底层的高性能数据操作方式。</p>
<p>第三，在 Java 7 中，NIO 有了进一步的改进，也就是 <strong>NIO 2</strong>，引入了<strong>异步非阻塞 IO</strong> 方式，也有很多人叫它 <strong>AIO</strong>（Asynchronous IO）。异步 IO 操作基于事件和回调机制，可以简单理解为，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。</p>
<hr>
<h4 id="12、Java-有几种文件拷贝方式？哪一种最高效？"><a href="#12、Java-有几种文件拷贝方式？哪一种最高效？" class="headerlink" title="12、Java 有几种文件拷贝方式？哪一种最高效？"></a>12、Java 有几种文件拷贝方式？哪一种最高效？</h4><p>Java 有多种比较典型的文件拷贝实现方式，比如：</p>
<p>利用 java.io 类库，直接为源文件构建一个 FileInputStream 读取，然后再为目标文件构建一个 FileOutputStream，完成写入工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByStream</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span><br><span class="line">        IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source);</span><br><span class="line">         <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);)&#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> length;</span><br><span class="line">        <span class="keyword">while</span> ((length = is.read(buffer)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            os.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>或者，利用 java.nio 类库提供的 transferTo 或 transferFrom 方法实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyFileByChannel</span><span class="params">(File source, File dest)</span> <span class="keyword">throws</span></span><br><span class="line">        IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">sourceChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(source)</span><br><span class="line">            .getChannel();</span><br><span class="line">         <span class="type">FileChannel</span> <span class="variable">targetChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest).getChannel</span><br><span class="line">                 ();)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> sourceChannel.size() ;count&gt;<span class="number">0</span> ;) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">transferred</span> <span class="operator">=</span> sourceChannel.transferTo(</span><br><span class="line">                    sourceChannel.position(), count, targetChannel);            sourceChannel.position(sourceChannel.position() + transferred);</span><br><span class="line">            count -= transferred;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当然，Java 标准类库本身已经提供了几种 Files.copy 的实现。</p>
<p>对于 Copy 的效率，这个其实与操作系统和配置等情况相关，总体上来说，NIO transferTo&#x2F;From 的方式可能更快，因为它更能利用现代操作系统底层机制，避免不必要拷贝和上下文切换。</p>
<hr>
<h4 id="13、谈谈接口和抽象类有什么区别？"><a href="#13、谈谈接口和抽象类有什么区别？" class="headerlink" title="13、谈谈接口和抽象类有什么区别？"></a>13、谈谈接口和抽象类有什么区别？</h4><p>接口和抽象类是 Java 面向对象设计的两个基础机制。</p>
<p><strong>接口</strong>是对行为的抽象，它是抽象方法的集合，利用接口可以达到 API 定义和实现分离的目的。接口，不能实例化；不能包含任何非常量成员，任何 field 都是隐含着 public static final 的意义；同时，没有非静态方法实现，也就是说<strong>要么是抽象方法，要么是静态方法</strong>。Java 标准类库中，定义了非常多的接口，比如 java.util.List。</p>
<p><strong>抽象类</strong>是不能实例化的类，用 abstract 关键字修饰 class，其目的主要是代码重用。除了不能实例化，形式上和一般的 Java 类并没有太大区别，可以有一个或者多个抽象方法，也可以没有抽象方法。抽象类大多用于抽取相关 Java 类的共用方法实现或者是共同成员变量，然后通过继承的方式达到代码复用的目的。Java 标准库中，比如 collection 框架，很多通用部分就被抽取成为抽象类，例如 java.util.AbstractList。</p>
<p>Java 类实现 interface 使用 <strong>implements</strong> 关键词，继承 abstract class 则是使用 <strong>extends</strong> 关键词，我们可以参考 Java 标准库中的 ArrayList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="14、谈谈你知道的设计模式？请手动实现单例模式，Spring-等框架中使用了哪些模式？"><a href="#14、谈谈你知道的设计模式？请手动实现单例模式，Spring-等框架中使用了哪些模式？" class="headerlink" title="14、谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？"></a>14、谈谈你知道的设计模式？请手动实现单例模式，Spring 等框架中使用了哪些模式？</h4><p>大致按照模式的应用目标分类，设计模式可以分为创建型模式、结构型模式和行为型模式。</p>
<ul>
<li><strong>创建型模式</strong>，是对对象创建过程的各种问题和解决方案的总结，包括各种工厂模式（Factory、Abstract Factory）、单例模式（Singleton）、构建器模式（Builder）、原型模式（ProtoType）。</li>
<li><strong>结构型模式</strong>，是针对软件设计结构的总结，关注于类、对象继承、组合方式的实践经验。常见的结构型模式，包括桥接模式（Bridge）、适配器模式（Adapter）、装饰者模式（Decorator）、代理模式（Proxy）、组合模式（Composite）、外观模式（Facade）、享元模式（Flyweight）等。</li>
<li><strong>行为型模式</strong>，是从类或对象之间交互、职责划分等角度总结的模式。比较常见的行为型模式有策略模式（Strategy）、解释器模式（Interpreter）、命令模式（Command）、观察者模式（Observer）、迭代器模式（Iterator）、模板方法模式（Template Method）、访问者模式（Visitor）。</li>
</ul>
<hr>
<h3 id="Java-进阶"><a href="#Java-进阶" class="headerlink" title="Java 进阶"></a>Java 进阶</h3><h4 id="15、synchronized-和-ReentrantLock-有什么区别？有人说-synchronized-最慢，这话靠谱吗？"><a href="#15、synchronized-和-ReentrantLock-有什么区别？有人说-synchronized-最慢，这话靠谱吗？" class="headerlink" title="15、synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？"></a>15、synchronized 和 ReentrantLock 有什么区别？有人说 synchronized 最慢，这话靠谱吗？</h4><p>synchronized 是 Java 内建的同步机制，所以也有人称其为 Intrinsic Locking，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里。</p>
<p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起来。</p>
<p>ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p>
<p>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock。</p>
<hr>
<h4 id="16、synchronized-底层如何实现？什么是锁的升级、降级？"><a href="#16、synchronized-底层如何实现？什么是锁的升级、降级？" class="headerlink" title="16、synchronized 底层如何实现？什么是锁的升级、降级？"></a>16、synchronized 底层如何实现？什么是锁的升级、降级？</h4><p>synchronized 代码块是由一对儿 monitorenter&#x2F;monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。</p>
<p>在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。</p>
<p>现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。</p>
<p>所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。</p>
<p>当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</p>
<p>如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p>
<p>我注意到有的观点认为 Java 不会进行锁降级。实际上据我所知，锁降级确实是会发生的，当 JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。</p>
<hr>
<h4 id="17、一个线程两次调用-start-方法会出现什么情况？谈谈线程的生命周期和状态转移。"><a href="#17、一个线程两次调用-start-方法会出现什么情况？谈谈线程的生命周期和状态转移。" class="headerlink" title="17、一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。"></a>17、一个线程两次调用 start() 方法会出现什么情况？谈谈线程的生命周期和状态转移。</h4><p>Java 的线程是不允许启动两次的，第二次调用必然会抛出 IllegalThreadStateException，这是一种运行时异常，多次调用 start 被认为是编程错误。</p>
<p>关于线程生命周期的不同状态，在 Java 5 以后，线程状态被明确定义在其<strong>公共内部枚举类型</strong> java.lang.Thread.State 中，分别是：</p>
<ul>
<li><strong>新建（NEW）</strong>，表示线程被创建出来还没真正启动的状态，可以认为它是个 Java 内部状态。</li>
<li><strong>就绪（RUNNABLE）</strong>，表示该线程已经在 JVM 中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它 CPU 片段，在就绪队列里面排队。</li>
<li>在其他一些分析中，会额外区分一种状态 <strong>RUNNING</strong>，但是从 Java API 的角度，并不能表示出来。</li>
<li><strong>阻塞（BLOCKED）</strong>，这个状态和我们前面两讲介绍的同步非常相关，阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。</li>
<li><strong>等待（WAITING）</strong>，表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。</li>
<li><strong>计时等待（TIMED_WAIT）</strong>，其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>终止（TERMINATED）</strong>，不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也有人把这个状态叫作死亡。</li>
</ul>
<p>在第二次调用 start() 方法的时候，线程可能处于终止或者其他（非 NEW）状态，但是不论如何，都是不可以再次启动的。</p>
<hr>
<h4 id="18、什么情况下-Java-程序会产生死锁？如何定位、修复？"><a href="#18、什么情况下-Java-程序会产生死锁？如何定位、修复？" class="headerlink" title="18、什么情况下 Java 程序会产生死锁？如何定位、修复？"></a>18、什么情况下 Java 程序会产生死锁？如何定位、修复？</h4><p>死锁是一种特定的程序状态，在实体之间，由于<strong>循环依赖</strong>导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指<strong>两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态</strong>。</p>
<p>你可以利用下面的示例图理解基本的死锁问题：</p>
<p><img src="https://image.luziyangde.cn//img/20210310210018.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210310210018.png" srcset="img/loadingImage.png"></p>
<p>定位死锁最常见的方式就是利用 jstack 等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。</p>
<p>如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。</p>
<hr>
<h4 id="19、Java-并发包提供了哪些并发工具类？"><a href="#19、Java-并发包提供了哪些并发工具类？" class="headerlink" title="19、Java 并发包提供了哪些并发工具类？"></a>19、Java 并发包提供了哪些并发工具类？</h4><p>我们通常所说的并发包也就是 java.util.concurrent 及其子包，集中了 Java 并发的各种基础工具类，具体主要包括几个方面：</p>
<ul>
<li><strong>提供了比 synchronized 更加高级的各种同步结构</strong>，包括 CountDownLatch、CyclicBarrier、Semaphore 等，可以实现更加丰富的多线程操作，比如利用 Semaphore 作为资源控制器，限制同时进行工作的线程数量。</li>
<li><strong>各种线程安全的容器</strong>，比如最常见的 ConcurrentHashMap、有序的 ConcurrentSkipListMap，或者通过类似<strong>快照</strong>机制，实现线程安全的动态数组 CopyOnWriteArrayList 等。</li>
<li><strong>各种并发队列实现</strong>，如各种 BlockingQueue 实现，比较典型的 ArrayBlockingQueue、 SynchronousQueue 或针对特定场景的 PriorityBlockingQueue 等。</li>
<li><strong>强大的 Executor 框架</strong>，可以创建各种不同类型的线程池，调度任务运行等，绝大部分情况下，不再需要自己从头实现线程池和任务调度器。</li>
</ul>
<hr>
<h4 id="20、并发包中的-ConcurrentLinkedQueue-和-LinkedBlockingQueue-有什么区别？"><a href="#20、并发包中的-ConcurrentLinkedQueue-和-LinkedBlockingQueue-有什么区别？" class="headerlink" title="20、并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？"></a>20、并发包中的 ConcurrentLinkedQueue 和 LinkedBlockingQueue 有什么区别？</h4><p>有时候我们把并发包下面的所有容器都习惯叫作并发容器，但是严格来讲，类似 ConcurrentLinkedQueue 这种“Concurrent*”容器，才是真正代表并发。</p>
<p>关于问题中它们的区别：</p>
<ul>
<li>Concurrent 类型基于 lock-free，在常见的多线程访问场景，一般可以提供较高吞吐量。</li>
<li>而 LinkedBlockingQueue 内部则是基于锁，并提供了 BlockingQueue 的等待性方法。</li>
</ul>
<p>不知道你有没有注意到，java.util.concurrent 包提供的容器（Queue、List、Set）、Map，从命名上可以大概区分为 Concurrent*、CopyOnWrite和 Blocking等三类，同样是线程安全容器，可以简单认为：</p>
<ul>
<li>Concurrent 类型没有类似 CopyOnWrite 之类容器相对较重的修改开销。但是，凡事都是有代价的，Concurrent 往往提供了较低的遍历一致性。你可以这样理解所谓的弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历。</li>
<li>与弱一致性对应的，就是我介绍过的同步容器常见的行为“fail-fast”，也就是检测到容器在遍历过程中发生了修改，则抛出 ConcurrentModificationException，不再继续遍历。</li>
<li>弱一致性的另外一个体现是，size 等操作准确性是有限的，未必是 100% 准确。</li>
<li>与此同时，读取的性能具有一定的不确定性。</li>
</ul>
<hr>
<h4 id="21、Java-并发类库提供的线程池有哪几种？-分别有什么特点？"><a href="#21、Java-并发类库提供的线程池有哪几种？-分别有什么特点？" class="headerlink" title="21、Java 并发类库提供的线程池有哪几种？ 分别有什么特点？"></a>21、Java 并发类库提供的线程池有哪几种？ 分别有什么特点？</h4><p>通常开发者都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。</p>
<p>Executors 目前提供了 5 种不同的线程池创建配置：</p>
<ul>
<li>newCachedThreadPool()，它是一种用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。</li>
<li>newFixedThreadPool(int nThreads)，重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有 nThreads 个工作线程是活动的。这意味着，如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。</li>
<li>newSingleThreadExecutor()，它的特点在于工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务的都是被顺序执行，最多会有一个任务处于活动状态，并且不允许使用者改动线程池实例，因此可以避免其改变线程数目。</li>
<li>newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是个 ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。</li>
<li>newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。</li>
</ul>
<hr>
<h4 id="22、AtomicInteger-底层实现原理是什么？如何在自己的产品代码中应用-CAS-操作？"><a href="#22、AtomicInteger-底层实现原理是什么？如何在自己的产品代码中应用-CAS-操作？" class="headerlink" title="22、AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？"></a>22、AtomicInteger 底层实现原理是什么？如何在自己的产品代码中应用 CAS 操作？</h4><p>AtomicIntger 是对 int 类型的一个封装，提供原子性的访问和更新操作，其原子性操作的实现是基于 CAS（compare-and-swap）技术。</p>
<p>所谓 CAS，表征的是一些列操作的集合，获取当前数值，进行一些运算，利用 CAS 指令试图进行更新。如果当前数值未变，代表没有其他线程进行并发修改，则成功更新。否则，可能出现不同的选择，要么进行重试，要么就返回一个成功或者失败的结果。</p>
<p>从 AtomicInteger 的内部属性可以看出，它依赖于 Unsafe 提供的一些底层能力，进行底层操作；以 volatile 的 value 字段，记录数值，以保证可见性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> jdk.internal.misc.<span class="type">Unsafe</span> <span class="variable">U</span> <span class="operator">=</span> jdk.internal.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">VALUE</span> <span class="operator">=</span> U.objectFieldOffset(AtomicInteger.class, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br></pre></td></tr></table></figure>

<p>具体的原子操作细节，可以参考任意一个原子更新方法，比如下面的 getAndIncrement。</p>
<p>Unsafe 会利用 value 字段的内存地址偏移，直接完成操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="built_in">this</span>, VALUE, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 getAndIncrement 需要返归数值，所以需要添加失败重试逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        v = getIntVolatile(o, offset);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而类似 compareAndSet 这种返回 boolean 类型的函数，因为其返回值表现的就是成功与否，所以不需要重试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expectedValue, <span class="type">int</span> newValue)</span></span><br></pre></td></tr></table></figure>

<p>CAS 是 Java 并发中所谓 lock-free 机制的基础。</p>
<hr>
<h4 id="23、请介绍类加载过程，什么是双亲委派模型？"><a href="#23、请介绍类加载过程，什么是双亲委派模型？" class="headerlink" title="23、请介绍类加载过程，什么是双亲委派模型？"></a>23、请介绍类加载过程，什么是双亲委派模型？</h4><p>一般来说，我们把 Java 的类加载过程分为三个主要步骤：加载、链接、初始化，具体行为在Java 虚拟机规范里有非常详细的定义。</p>
<p>首先是<strong>加载</strong>阶段（Loading），它是 Java 将字节码数据从不同的数据源读取到 JVM 中，并映射为 JVM 认可的数据结构（Class 对象），这里的数据源可能是各种各样的形态，如 jar 文件、class 文件，甚至是网络数据源等；如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<p>加载阶段是用户参与的阶段，我们可以自定义类加载器，去实现自己的类加载过程。</p>
<p>第二阶段是<strong>链接</strong>（Linking），这是核心的步骤，简单说是把原始的类定义信息平滑地转化入 JVM 运行的过程中。这里可进一步细分为三个步骤：</p>
<ul>
<li><strong>验证</strong>（Verification），这是虚拟机安全的重要保障，JVM 需要核验字节信息是符合 Java 虚拟机规范的，否则就被认为是 VerifyError，这样就防止了恶意信息或者不合规的信息危害 JVM 的运行，验证阶段有可能触发更多 class 的加载。</li>
<li><strong>准备</strong>（Preparation），创建类或接口中的静态变量，并初始化静态变量的初始值。但这里的“初始化”和下面的显式初始化阶段是有区别的，侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令。</li>
<li><strong>解析</strong>（Resolution），在这一步会将常量池中的符号引用（symbolic reference）替换为直接引用。在Java 虚拟机规范中，详细介绍了类、接口、方法和字段等各个方面的解析。</li>
</ul>
<p>最后是<strong>初始化</strong>阶段（initialization），这一步真正去执行类初始化的代码逻辑，包括静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑，编译器在编译阶段就会把这部分逻辑整理好，父类型的初始化逻辑优先于当前类型的逻辑。</p>
<p>再来谈谈<strong>双亲委派模型</strong>，简单说就是当类加载器（Class-Loader）试图加载某个类型的时候，除非父加载器找不到相应类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模型的目的是避免重复加载 Java 类型。</p>
<hr>
<h4 id="24、有哪些方法可以在运行时动态生成一个-Java-类？"><a href="#24、有哪些方法可以在运行时动态生成一个-Java-类？" class="headerlink" title="24、有哪些方法可以在运行时动态生成一个 Java 类？"></a>24、有哪些方法可以在运行时动态生成一个 Java 类？</h4><p>我们可以从常见的 Java 类来源分析，通常的开发过程是，开发者编写 Java 代码，调用 javac 编译成 class 文件，然后通过类加载机制载入 JVM，就成为应用运行时可以使用的 Java 类了。</p>
<p>从上面过程得到启发，其中一个直接的方式是从源码入手，可以利用 Java 程序生成一段源码，然后保存到文件等，下面就只需要解决编译问题了。</p>
<p>有一种笨办法，直接用 ProcessBuilder 之类启动 javac 进程，并指定上面生成的文件作为输入，进行编译。最后，再利用类加载器，在运行时加载即可。</p>
<p>前面的方法，本质上还是在当前程序进程之外编译的，那么还有没有不这么 low 的办法呢？</p>
<p>你可以考虑使用 Java Compiler API，这是 JDK 提供的标准 API，里面提供了与 javac 对等的编译器功能，具体请参考java.compiler相关文档。</p>
<p>进一步思考，我们一直围绕 Java 源码编译成为 JVM 可以理解的字节码，换句话说，只要是符合 JVM 规范的字节码，不管它是如何生成的，是不是都可以被 JVM 加载呢？我们能不能直接生成相应的字节码，然后交给类加载器去加载呢？</p>
<p>当然也可以，不过直接去写字节码难度太大，通常我们可以利用 Java 字节码操纵工具和类库来实现，比如在专栏第 6 讲中提到的ASM、Javassist、cglib 等。</p>
<hr>
<h4 id="25、谈谈-JVM-内存区域的划分，哪些区域可能发生-OutOfMemoryError？"><a href="#25、谈谈-JVM-内存区域的划分，哪些区域可能发生-OutOfMemoryError？" class="headerlink" title="25、谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？"></a>25、谈谈 JVM 内存区域的划分，哪些区域可能发生 OutOfMemoryError？</h4><p>通常可以把 JVM 内存区域分为下面几个方面，其中，有的区域是以线程为单位，而有的区域则是整个 JVM 进程唯一的。</p>
<p>首先，<strong>程序计数器</strong>（PC，Program Counter Register）。在 JVM 规范中，每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。</p>
<p>第二，<strong>Java 虚拟机栈</strong>（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用。</p>
<p>前面谈程序计数器时，提到了当前方法；同理，在一个时间点，对应的只会有一个活动的栈帧，通常叫作当前帧，方法所在的类叫作当前类。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，成为新的当前帧，一直到它返回结果或者执行结束。JVM 直接对 Java 栈的操作只有两个，就是对栈帧的压栈和出栈。</p>
<p>栈帧中存储着局部变量表、操作数（operand）栈、动态链接、方法正常退出或者异常退出的定义等。</p>
<p>第三，<strong>堆</strong>（Heap），它是 Java 内存管理的核心区域，用来放置 Java 对象实例，几乎所有创建的 Java 对象实例都是被直接分配在堆上。堆被所有的线程共享，在虚拟机启动时，我们指定的“Xmx”之类参数就是用来指定最大堆空间等指标。</p>
<p>理所当然，堆也是垃圾收集器重点照顾的区域，所以堆内空间还会被不同的垃圾收集器进行进一步的细分，最有名的就是<strong>新生代</strong>、<strong>老年代</strong>的划分。</p>
<p>第四，<strong>方法区</strong>（Method Area）。这也是<strong>所有线程共享的一块内存区域</strong>，用于存储所谓的<strong>元（Meta）数据</strong>，例如类结构信息，以及对应的运行时常量池、字段、方法代码等。</p>
<p>由于早期的 Hotspot JVM 实现，很多人习惯于将方法区称为永久代（Permanent Generation）。Oracle JDK 8 中将永久代移除，同时增加了元数据区（Metaspace）。</p>
<p>第五，<strong>运行时常量池</strong>（Run-Time Constant Pool），这是方法区的一部分。如果仔细分析过反编译的类文件结构，你能看到版本号、字段、方法、超类、接口等各种信息，还有一项信息就是常量池。Java 的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。</p>
<p>第六，<strong>本地方法栈</strong>（Native Method Stack）。它和 Java 虚拟机栈是非常相似的，支持对本地方法的调用，也是每个线程都会创建一个。在 Oracle Hotspot JVM 中，本地方法栈和 Java 虚拟机栈是在同一块儿区域，这完全取决于技术实现的决定，并未在规范中强制。</p>
<p><img src="https://image.luziyangde.cn//img/360b8f453e016cb641208a6a8fb589bc.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/360b8f453e016cb641208a6a8fb589bc.png" srcset="img/loadingImage.png" alt="img"></p>
<hr>
<h4 id="26、如何监控和诊断-JVM-堆内和堆外内存使用？"><a href="#26、如何监控和诊断-JVM-堆内和堆外内存使用？" class="headerlink" title="26、如何监控和诊断 JVM 堆内和堆外内存使用？"></a>26、如何监控和诊断 JVM 堆内和堆外内存使用？</h4><p>了解 JVM 内存的方法有很多，具体能力范围也有区别，简单总结如下：</p>
<ul>
<li>可以使用综合性的图形化工具，如 JConsole、VisualVM（注意，从 Oracle JDK 9 开始，VisualVM 已经不再包含在 JDK 安装包中）等。这些工具具体使用起来相对比较直观，直接连接到 Java 进程，然后就可以在图形化界面里掌握内存使用情况。</li>
</ul>
<p>以 JConsole 为例，其内存页面可以显示常见的<strong>堆内存</strong>和各种<strong>堆外部分</strong>使用状态。</p>
<ul>
<li>也可以使用命令行工具进行运行时查询，如 jstat 和 jmap 等工具都提供了一些选项，可以查看堆、方法区等使用数据。</li>
<li>或者，也可以使用 jmap 等提供的命令，生成堆转储（Heap Dump）文件，然后利用 jhat 或 Eclipse MAT 等堆转储分析工具进行详细分析。</li>
<li>如果你使用的是 Tomcat、Weblogic 等 Java EE 服务器，这些服务器同样提供了内存管理相关的功能。</li>
<li>另外，从某种程度上来说，GC 日志等输出，同样包含着丰富的信息。</li>
</ul>
<p>这里有一个相对特殊的部分，就是是堆外内存中的直接内存，前面的工具基本不适用，可以使用 JDK 自带的 Native Memory Tracking（NMT）特性，它会从 JVM 本地内存分配的角度进行解读。</p>
<hr>
<h4 id="27、Java-常见的垃圾收集器有哪些？"><a href="#27、Java-常见的垃圾收集器有哪些？" class="headerlink" title="27、Java 常见的垃圾收集器有哪些？"></a>27、Java 常见的垃圾收集器有哪些？</h4><p>实际上，垃圾收集器（GC，Garbage Collector）是和具体 JVM 实现紧密相关的，不同厂商（IBM、Oracle），不同版本的 JVM，提供的选择也不同。接下来，我来谈谈最主流的 Oracle JDK。</p>
<ul>
<li><p><strong>Serial GC</strong>，它是最古老的垃圾收集器，“Serial”体现在其收集工作是<strong>单线程</strong>的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World”状态。当然，其单线程设计也意味着精简的 GC 实现，无需维护复杂的数据结构，初始化也简单，所以一直是 Client 模式下 JVM 的默认选项。</p>
<p>从年代的角度，通常将其老年代实现单独称作 Serial Old，它采用了<strong>标记 - 整理（Mark-Compact）算法</strong>，区别于新生代的<strong>复制算法</strong>。</p>
<p>Serial GC 的对应 JVM 参数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ParNew GC</strong>，很明显是个新生代 GC 实现，它实际是 Serial GC 的<strong>多线程</strong>版本，最常见的应用场景是配合老年代的 CMS GC 工作，下面是对应参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC -XX:+UseParNewGC</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CMS（Concurrent Mark Sweep） GC</strong>，基于<strong>标记 - 清除（Mark-Sweep）算法</strong>，设计目标是<strong>尽量减少停顿时间</strong>，这一点对于 Web 等反应时间敏感的应用非常重要，一直到今天，仍然有很多系统使用 CMS GC。但是，CMS 采用的标记 - 清除算法，存在着内存碎片化问题，所以难以避免在长时间运行等情况下发生 full GC，导致恶劣的停顿。另外，既然强调了<strong>并发</strong>（Concurrent），CMS 会占用更多 CPU 资源，并和用户线程争抢。</p>
</li>
<li><p><strong>Parallel GC</strong>，在早期 JDK 8 等版本中，它是 server 模式 JVM 的默认 GC 选择，也被称作是<strong>吞吐量优先</strong>的 GC。它的算法和 Serial GC 比较相似，尽管实现要复杂的多，其特点是<strong>新生代和老年代 GC 都是并行进行的</strong>，在常见的服务器环境中更加高效。开启选项是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC</span><br></pre></td></tr></table></figure>

<p>另外，Parallel GC 引入了开发者友好的配置项，我们可以直接设置暂停时间或吞吐量等目标，JVM 会自动进行适应性调整，例如下面参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=value</span><br><span class="line">-XX:GCTimeRatio=N <span class="comment">// GC时间和用户时间比例 = 1 / (N+1)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>G1 GC</strong> 这是一种<strong>兼顾吞吐量和停顿时间</strong>的 GC 实现，是 <strong>Oracle JDK 9 以后的默认 GC 选项</strong>。G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p>
<p>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 region。Region 之间是<strong>复制算法</strong>，但整体上实际可看作是<strong>标记 - 整理（Mark-Compact）算法</strong>，<strong>可以有效地避免内存碎片</strong>，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</p>
<p>G1 吞吐量和停顿表现都非常不错，并且仍然在不断地完善，与此同时 CMS 已经在 JDK 9 中被标记为废弃（deprecated），所以 G1 GC 值得你深入掌握。</p>
</li>
</ul>
<hr>
<h4 id="28、谈谈你的-GC-调优思路？"><a href="#28、谈谈你的-GC-调优思路？" class="headerlink" title="28、谈谈你的 GC 调优思路？"></a>28、谈谈你的 GC 调优思路？</h4><p>谈到调优，这一定是针对特定场景、特定目的的事情， 对于 GC 调优来说，首先就需要清楚调优的目标是什么？从性能的角度看，通常关注三个方面，<strong>内存占用（footprint）</strong>、<strong>延时（latency）</strong>和<strong>吞吐量（throughput）</strong>，大多数情况下调优会侧重于其中一个或者两个方面的目标，很少有情况可以兼顾三个不同的角度。当然，除了上面通常的三个方面，也可能需要考虑其他 GC 相关的场景，例如，OOM 也可能与不合理的 GC 相关参数有关；或者，应用启动速度方面的需求，GC 也会是个考虑的方面。</p>
<p>基本的调优思路可以总结为：</p>
<ul>
<li><strong>理解应用需求和问题，确定调优目标。</strong>假设，我们开发了一个应用服务，但发现偶尔会出现性能抖动，出现较长的服务停顿。评估用户可接受的响应时间和业务量，将目标简化为，希望 GC 暂停尽量控制在 200ms 以内，并且保证一定标准的吞吐量。</li>
<li><strong>掌握 JVM 和 GC 的状态，定位具体的问题，确定真的有 GC 调优的必要。</strong>具体有很多方法，比如，通过 jstat 等工具查看 GC 等相关状态，可以开启 GC 日志，或者是利用操作系统提供的诊断工具等。例如，通过追踪 GC 日志，就可以查找是不是 GC 在特定时间发生了长时间的暂停，进而导致了应用响应不及时。</li>
<li>这里需要思考，<strong>选择的 GC 类型是否符合我们的应用特征</strong>，如果是，具体问题表现在哪里，是 Minor GC 过长，还是 Mixed GC 等出现异常停顿情况；如果不是，考虑切换到什么类型，如 CMS 和 G1 都是更侧重于低延迟的 GC 选项。</li>
<li><strong>通过分析确定具体调整的参数或者软硬件配置。</strong></li>
<li><strong>验证是否达到调优目标</strong>，如果达到目标，即可以考虑结束调优；否则，重复完成分析、调整、验证这个过程。</li>
</ul>
<hr>
<h4 id="29、Java-内存模型中的-happen-before-是什么？"><a href="#29、Java-内存模型中的-happen-before-是什么？" class="headerlink" title="29、Java 内存模型中的 happen-before 是什么？"></a>29、Java 内存模型中的 happen-before 是什么？</h4><p><strong>Happen-before 关系，是 Java 内存模型中保证多线程操作可见性的机制</strong>，也是对早期语言规范中含糊的可见性概念的一个精确定义。</p>
<p>它的具体表现形式，包括但远不止是我们直觉中的 synchronized、volatile、lock 操作顺序等方面，例如：</p>
<ul>
<li>线程内执行的每个操作，都保证 happen-before 后面的操作，这就保证了基本的程序顺序规则，这是开发者在书写程序时的基本约定。</li>
<li>对于 volatile 变量，对它的写操作，保证 happen-before 在随后对该变量的读取操作。</li>
<li>对于一个锁的解锁操作，保证 happen-before 加锁操作。</li>
<li>对象构建完成，保证 happen-before 于 finalizer 的开始动作。</li>
<li>甚至是类似线程内部操作的完成，保证 happen-before 其他 Thread.join() 的线程等。</li>
</ul>
<p>这些 happen-before 关系是存在着传递性的，如果满足 a happen-before b 和 b happen-before c，那么 a happen-before c 也成立。</p>
<p>前面我一直用 happen-before，而不是简单说前后，是因为它不仅仅是对执行时间的保证，也包括对内存读、写操作顺序的保证。仅仅是时钟顺序上的先后，并不能保证线程交互的可见性。</p>
<hr>
<h4 id="30、Java-程序运行在-Docker-等容器环境有哪些新问题？"><a href="#30、Java-程序运行在-Docker-等容器环境有哪些新问题？" class="headerlink" title="30、Java 程序运行在 Docker 等容器环境有哪些新问题？"></a>30、Java 程序运行在 Docker 等容器环境有哪些新问题？</h4><p>对于 Java 来说，Docker 毕竟是一个较新的环境，例如，其内存、CPU 等资源限制是通过 CGroup（Control Group）实现的，早期的 JDK 版本（8u131 之前）并不能识别这些限制，进而会导致一些基础问题：</p>
<ul>
<li>如果未配置合适的 JVM 堆和元数据区、直接内存等参数，Java 就有可能试图使用超过容器限制的内存，最终被容器 OOM kill，或者自身发生 OOM。</li>
<li>错误判断了可获取的 CPU 资源，例如，Docker 限制了 CPU 的核数，JVM 就可能设置不合适的 GC 并行线程数等。</li>
</ul>
<p>从应用打包、发布等角度出发，JDK 自身就比较大，生成的镜像就更为臃肿，当我们的镜像非常多的时候，镜像的存储等开销就比较明显了。</p>
<p>如果考虑到微服务、Serverless 等新的架构和场景，Java 自身的大小、内存占用、启动速度，都存在一定局限性，因为 Java 早期的优化大多是针对长时间运行的大型服务器端应用。</p>
<hr>
<h3 id="Java安全基础"><a href="#Java安全基础" class="headerlink" title="Java安全基础"></a>Java安全基础</h3><h4 id="31、你了解-Java-应用开发中的注入攻击吗？"><a href="#31、你了解-Java-应用开发中的注入攻击吗？" class="headerlink" title="31、你了解 Java 应用开发中的注入攻击吗？"></a>31、你了解 Java 应用开发中的注入攻击吗？</h4><p>注入式（Inject）攻击是一类非常常见的攻击方式，其基本特征是程序允许攻击者将不可信的动态内容注入到程序中，并将其执行，这就可能完全改变最初预计的执行过程，产生恶意效果。</p>
<p>下面是几种主要的注入式攻击途径，原则上提供动态执行能力的语言特性，都需要提防发生注入攻击的可能。</p>
<p>首先，就是最常见的 <strong>SQL 注入攻击</strong>。一个典型的场景就是 Web 系统的用户登录功能，根据用户输入的用户名和密码，我们需要去后端数据库核实信息。</p>
<p>假设应用逻辑是，后端程序利用界面输入动态生成类似下面的 SQL，然后让 JDBC 执行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> use_info <span class="keyword">where</span> username <span class="operator">=</span> “input_usr_name” <span class="keyword">and</span> password <span class="operator">=</span> “input_pwd”</span><br></pre></td></tr></table></figure>

<p>但是，如果我输入的 input_pwd 是类似下面的文本，</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“ <span class="keyword">or</span> “”<span class="operator">=</span>”</span><br></pre></td></tr></table></figure>

<p>那么，拼接出的 SQL 字符串就变成了下面的条件，OR 的存在导致输入什么名字都是复合条件的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> use_info <span class="keyword">where</span> username <span class="operator">=</span> “input_usr_name” <span class="keyword">and</span> password <span class="operator">=</span> “” <span class="keyword">or</span> “” <span class="operator">=</span> “”</span><br></pre></td></tr></table></figure>

<p>这里只是举个简单的例子，它是利用了期望输入和可能输入之间的偏差。上面例子中，期望用户输入一个数值，但实际输入的则是 SQL 语句片段。类似场景可以利用注入的不同 SQL 语句，进行各种不同目的的攻击，甚至还可以加上“;delete xxx”之类语句，如果数据库权限控制不合理，攻击效果就可能是灾难性的。</p>
<p>第二，<strong>操作系统命令注入</strong>。Java 语言提供了类似 Runtime.exec(…) 的 API，可以用来执行特定命令，假设我们构建了一个应用，以输入文本作为参数，执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls –la input_file_name</span><br></pre></td></tr></table></figure>

<p>但是如果用户输入是 “input_file_name;rm –rf &#x2F;*”，这就有可能出现问题了。当然，这只是个举例，Java 标准类库本身进行了非常多的改进，所以类似这种编程错误，未必可以真的完成攻击，但其反映的一类场景是真实存在的。</p>
<p>第三，<strong>XML 注入攻击</strong>。Java 核心类库提供了全面的 XML 处理、转换等各种 API，而 XML 自身是可以包含动态内容的，例如 XPATH，如果使用不当，可能导致访问恶意内容。</p>
<p>还有类似 LDAP 等允许动态内容的协议，都是可能利用特定命令，构造注入式攻击的，包括 XSS（Cross-site Scripting）攻击，虽然并不和 Java 直接相关，但也可能在 JSP 等动态页面中发生。</p>
<hr>
<h4 id="32、如何写出安全的-Java-代码？"><a href="#32、如何写出安全的-Java-代码？" class="headerlink" title="32、如何写出安全的 Java 代码？"></a>32、如何写出安全的 Java 代码？</h4><p>这个问题可能有点宽泛，我们可以用特定类型的安全风险为例，如拒绝服务（DoS）攻击，分析 Java 开发者需要重点考虑的点。</p>
<p>DoS 是一种常见的网络攻击，有人也称其为“洪水攻击”。最常见的表现是，利用大量机器发送请求，将目标网站的带宽或者其他资源耗尽，导致其无法响应正常用户的请求。</p>
<p>我认为，从 Java 语言的角度，更加需要重视的是程序级别的攻击，也就是利用 Java、JVM 或应用程序的瑕疵，进行低成本的 DoS 攻击，这也是想要写出安全的 Java 代码所必须考虑的。例如：</p>
<ul>
<li>如果使用的是早期的 JDK 和 Applet 等技术，攻击者构建合法但恶劣的程序就相对容易，例如，将其线程优先级设置为最高，做一些看起来无害但空耗资源的事情。幸运的是类似技术已经逐步退出历史舞台，在 JDK 9 以后，相关模块就已经被移除。</li>
<li>上一讲中提到的哈希碰撞攻击，就是个典型的例子，对方可以轻易消耗系统有限的 CPU 和线程资源。从这个角度思考，类似加密、解密、图形处理等计算密集型任务，都要防范被恶意滥用，以免攻击者通过直接调用或者间接触发方式，消耗系统资源。</li>
<li>利用 Java 构建类似上传文件或者其他接受输入的服务，需要对消耗系统内存或存储的上限有所控制，因为我们不能将系统安全依赖于用户的合理使用。其中特别注意的是涉及解压缩功能时，就需要防范Zip bomb等特定攻击。</li>
<li>另外，Java 程序中需要明确释放的资源有很多种，比如文件描述符、数据库连接，甚至是再入锁，任何情况下都应该保证资源释放成功，否则即使平时能够正常运行，也可能被攻击者利用而耗尽某类资源，这也算是可能的 DoS 攻击来源。</li>
</ul>
<p>所以可以看出，实现安全的 Java 代码，需要从功能设计到实现细节，都充分考虑可能的安全影响。</p>
<hr>
<h3 id="Java性能基础"><a href="#Java性能基础" class="headerlink" title="Java性能基础"></a>Java性能基础</h3><h4 id="33、后台服务出现明显“变慢”，谈谈你的诊断思路？"><a href="#33、后台服务出现明显“变慢”，谈谈你的诊断思路？" class="headerlink" title="33、后台服务出现明显“变慢”，谈谈你的诊断思路？"></a>33、后台服务出现明显“变慢”，谈谈你的诊断思路？</h4><p>首先，需要对这个问题进行更加清晰的定义：</p>
<ul>
<li>服务是突然变慢还是长时间运行后观察到变慢？类似问题是否重复出现？</li>
<li>“慢”的定义是什么，我能够理解是系统对其他方面的请求的反应延时变长吗?</li>
</ul>
<p>第二，理清问题的症状，这更便于定位具体的原因，有以下一些思路：</p>
<ul>
<li><p>问题可能来自于 Java 服务自身，也可能仅仅是受系统里其他服务的影响。初始判断可以先确认是否出现了意外的程序错误，例如检查应用本身的错误日志。</p>
<p>对于分布式系统，很多公司都会实现更加系统的日志、性能等监控系统。一些 Java 诊断工具也可以用于这个诊断，例如通过 JFR（Java Flight Recorder），监控应用是否大量出现了某种类型的异常。</p>
<p>如果有，那么异常可能就是个突破点。</p>
<p>如果没有，可以先检查系统级别的资源等情况，监控 CPU、内存等资源是否被其他进程大量占用，并且这种占用是否不符合系统正常运行状况。</p>
</li>
<li><p>监控 Java 服务自身，例如 GC 日志里面是否观察到 Full GC 等恶劣情况出现，或者是否 Minor GC 在变长等；利用 jstat 等工具，获取内存使用的统计信息也是个常用手段；利用 jstack 等工具检查是否出现死锁等。</p>
</li>
<li><p>如果还不能确定具体问题，对应用进行 Profiling 也是个办法，但因为它会对系统产生侵入性，如果不是非常必要，大多数情况下并不建议在生产系统进行。</p>
</li>
<li><p>定位了程序错误或者 JVM 配置的问题后，就可以采取相应的补救措施，然后验证是否解决，否则还需要重复上面部分过程。</p>
</li>
</ul>
<hr>
<h4 id="34、有人说“Lambda-能让-Java-程序慢-30-倍”，你怎么看？"><a href="#34、有人说“Lambda-能让-Java-程序慢-30-倍”，你怎么看？" class="headerlink" title="34、有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？"></a>34、有人说“Lambda 能让 Java 程序慢 30 倍”，你怎么看？</h4><p>为了让你清楚地了解这个背景，请参考下面的代码片段。在实际运行中，基于 Lambda&#x2F;Stream 的版本（lambdaMaxInteger），比传统的 for-each 版本（forEachLoopMaxInteger）慢很多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个大的ArrayList，内部是随机的整形数据</span></span><br><span class="line"><span class="keyword">volatile</span> List&lt;Integer&gt; integers = …</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基准测试1</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">forEachLoopMaxInteger</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">   <span class="keyword">for</span> (Integer n : integers) &#123;</span><br><span class="line">    max = Integer.max(max, n);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基准测试2</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lambdaMaxInteger</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> integers.stream().reduce(Integer.MIN_VALUE, (a, b) -&gt; Integer.max(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我认为，“Lambda 能让 Java 程序慢 30 倍”这个争论实际反映了几个方面：</p>
<p>第一，基准测试是一个非常有效的通用手段，让我们以直观、量化的方式，判断程序在特定条件下的性能表现。</p>
<p>第二，基准测试必须明确定义自身的范围和目标，否则很有可能产生误导的结果。前面代码片段本身的逻辑就有瑕疵，更多的开销是源于自动装箱、拆箱（auto-boxing&#x2F;unboxing），而不是源自 Lambda 和 Stream，所以得出的初始结论是没有说服力的。</p>
<p>第三，虽然 Lambda&#x2F;Stream 为 Java 提供了强大的函数式编程能力，但是也需要正视其局限性：</p>
<ul>
<li>一般来说，我们可以认为 Lambda&#x2F;Stream 提供了与传统方式接近对等的性能，但是如果对于性能非常敏感，就不能完全忽视它在特定场景的性能差异了，例如：<strong>初始化的开销</strong>。 Lambda 并不算是语法糖，而是一种新的工作机制，在首次调用时，JVM 需要为其构建CallSite实例。这意味着，如果 Java 应用启动过程引入了很多 Lambda 语句，会导致启动过程变慢。其实现特点决定了 JVM 对它的优化可能与传统方式存在差异。</li>
<li>增加了程序诊断等方面的复杂性，程序栈要复杂很多，Fluent 风格本身也不算是对于调试非常友好的结构，并且在可检查异常的处理方面也存在着局限性等。</li>
</ul>
<hr>
<h4 id="35、JVM-优化-Java-代码时都做了什么？"><a href="#35、JVM-优化-Java-代码时都做了什么？" class="headerlink" title="35、JVM 优化 Java 代码时都做了什么？"></a>35、JVM 优化 Java 代码时都做了什么？</h4><p>JVM 在对代码执行的优化可分为<strong>运行时</strong>（runtime）优化和<strong>即时编译器</strong>（JIT）优化。</p>
<p><strong>运行时优化</strong>主要是解释执行和动态编译通用的一些机制，比如说锁机制（如偏斜锁）、内存分配机制（如 TLAB）等。除此之外，还有一些专门用于优化解释执行效率的，比如说模版解释器、内联缓存（inline cache，用于优化虚方法调用的动态绑定）。</p>
<p>JVM 的<strong>即时编译器优化</strong>是指将<strong>热点代码</strong>以方法为单位转换成机器码，直接运行在底层硬件之上。它采用了多种优化方式，包括静态编译器可以使用的如方法内联、逃逸分析，也包括基于程序运行 profile 的投机性优化（speculative&#x2F;optimistic optimization）。这个怎么理解呢？比如我有一条 instanceof 指令，在编译之前的执行过程中，测试对象的类一直是同一个，那么即时编译器可以假设编译之后的执行过程中还会是这一个类，并且根据这个类直接返回 instanceof 的结果。如果出现了其他类，那么就抛弃这段编译后的机器码，并且切换回解释执行。</p>
<p>当然，JVM 的优化方式仅仅作用在运行应用代码的时候。如果应用代码本身阻塞了，比如说并发时等待另一线程的结果，这就不在 JVM 的优化范畴啦。</p>
<hr>
<h3 id="Java应用开发扩展"><a href="#Java应用开发扩展" class="headerlink" title="Java应用开发扩展"></a>Java应用开发扩展</h3><h4 id="36、谈谈-MySQL-支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"><a href="#36、谈谈-MySQL-支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？" class="headerlink" title="36、谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？"></a>36、谈谈 MySQL 支持的事务隔离级别，以及悲观锁和乐观锁的原理和应用场景？</h4><p>所谓<strong>隔离级别</strong>（Isolation Level），就是在数据库事务中，为保证并发数据读写的正确性而提出的定义，它并不是 MySQL 专有的概念，而是源于ANSI&#x2F;ISO制定的SQL-92标准。</p>
<p>每种关系型数据库都提供了各自特色的隔离级别实现，虽然在通常的定义中是以锁为实现单元，但实际的实现千差万别。以最常见的 MySQL InnoDB 引擎为例，它是基于 <strong>MVCC</strong>（Multi-Versioning Concurrency Control）和<strong>锁的复合</strong>实现，按照隔离程度从低到高，MySQL 事务隔离级别分为四个不同层次：</p>
<ul>
<li><strong>读未提交</strong>（Read uncommitted），就是一个事务能够看到其他事务尚未提交的修改，这是最低的隔离水平，允许<strong>脏读</strong>出现。</li>
<li><strong>读已提交</strong>（Read committed），事务能够看到的数据都是其他事务已经提交的修改，也就是保证不会看到任何中间性状态，当然脏读也不会出现。读已提交仍然是比较低级别的隔离，并不保证再次读取时能够获取同样的数据，也就是允许其他事务并发修改数据，允许<strong>不可重复读</strong>和<strong>幻象读</strong>（Phantom Read）出现。</li>
<li><strong>可重复读</strong>（Repeatable reads），保证同一个事务中多次读取的数据是一致的，这是 MySQL InnoDB 引擎的默认隔离级别，但是和一些其他数据库实现不同的是，可以简单认为 MySQL 在可重复读级别不会出现幻象读。</li>
<li><strong>串行化</strong>（Serializable），并发事务之间是串行化的，通常意味着读取需要获取共享读锁，更新需要获取排他写锁，如果 SQL 使用 WHERE 语句，还会获取区间锁（MySQL 以 GAP 锁形式实现，可重复读级别中默认也会使用），这是最高的隔离级别。</li>
</ul>
<p>至于<strong>悲观锁和乐观锁</strong>，也并不是 MySQL 或者数据库中独有的概念，而是并发编程的基本概念。主要区别在于，操作共享数据时，“悲观锁”即认为数据出现冲突的可能性更大，而“乐观锁”则是认为大部分情况不会出现冲突，进而决定是否采取排他性措施。</p>
<p>反映到 MySQL 数据库应用开发中，悲观锁一般就是利用类似 SELECT … FOR UPDATE 这样的语句，对数据加锁，避免其他事务意外修改数据。乐观锁则与 Java 并发包中的 AtomicFieldUpdater 类似，也是利用 CAS 机制，并不会对数据加锁，而是通过对比数据的时间戳或者版本号，来实现乐观锁需要的版本判断。</p>
<p>我认为前面提到的 MVCC，其本质就可以看作是种乐观锁机制，而排他性的读写锁、双阶段锁等则是悲观锁的实现。</p>
<p>有关它们的应用场景，你可以构建一下简化的火车余票查询和购票系统。同时查询的人可能很多，虽然具体座位票只能是卖给一个人，但余票可能很多，而且也并不能预测哪个查询者会购票，这个时候就更适合用乐观锁。</p>
<hr>
<h4 id="37、谈谈-Spring-Bean-的生命周期和作用域？"><a href="#37、谈谈-Spring-Bean-的生命周期和作用域？" class="headerlink" title="37、谈谈 Spring Bean 的生命周期和作用域？"></a>37、谈谈 Spring Bean 的生命周期和作用域？</h4><p>Spring Bean 生命周期比较复杂，可以分为<strong>创建</strong>和<strong>销毁</strong>两个过程。</p>
<p>首先，创建 Bean 会经过一系列的步骤，主要包括：</p>
<ul>
<li>实例化 Bean 对象。</li>
<li>设置 Bean 属性。</li>
<li>如果我们通过各种 Aware 接口声明了依赖关系，则会注入 Bean 对容器基础设施层面的依赖。具体包括 BeanNameAware、BeanFactoryAware 和 ApplicationContextAware，分别会注入 Bean ID、Bean Factory 或者 ApplicationContext。</li>
<li>调用 BeanPostProcessor 的前置初始化方法 postProcessBeforeInitialization。</li>
<li>如果实现了 InitializingBean 接口，则会调用 afterPropertiesSet 方法。</li>
<li>调用 Bean 自身定义的 init 方法。</li>
<li>调用 BeanPostProcessor 的后置初始化方法 postProcessAfterInitialization。</li>
<li>创建过程完毕。</li>
</ul>
<p>你可以参考下面示意图理解这个具体过程和先后顺序。</p>
<p><img src="https://image.luziyangde.cn//img/3a51f06f56b905b8fbf1661359e1727e.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/3a51f06f56b905b8fbf1661359e1727e.png" srcset="img/loadingImage.png" alt="img"></p>
<p>第二，Spring Bean 的销毁过程会依次调用 DisposableBean 的 destroy 方法和 Bean 自身定制的 destroy 方法。</p>
<p>Spring Bean 有五个作用域，其中最基础的有下面两种：</p>
<ul>
<li><strong>Singleton</strong>，这是 Spring 的默认作用域，也就是为每个 IOC 容器创建唯一的一个 Bean 实例。</li>
<li><strong>Prototype</strong>，针对每个 getBean 请求，容器都会单独创建一个 Bean 实例。</li>
</ul>
<p>从 Bean 的特点来看，Prototype 适合<strong>有状态</strong>的 Bean，而 Singleton 则更适合<strong>无状态</strong>的情况。另外，使用 Prototype 作用域需要经过仔细思考，毕竟频繁创建和销毁 Bean 是有明显开销的。</p>
<p>如果是 Web 容器，则支持另外三种作用域：</p>
<ul>
<li>Request，为每个 HTTP 请求创建单独的 Bean 实例。</li>
<li>Session，很显然 Bean 实例的作用域是 Session 范围。</li>
<li>GlobalSession，用于 Portlet 容器，因为每个 Portlet 有单独的 Session，GlobalSession 提供一个全局性的 HTTP Session。</li>
</ul>
<hr>
<h4 id="38、对比-Java-标准-NIO-类库，你知道-Netty-是如何实现更高性能的吗？"><a href="#38、对比-Java-标准-NIO-类库，你知道-Netty-是如何实现更高性能的吗？" class="headerlink" title="38、对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？"></a>38、对比 Java 标准 NIO 类库，你知道 Netty 是如何实现更高性能的吗？</h4><p>单独从性能角度，Netty 在基础的 NIO 等类库之上进行了很多改进，例如：</p>
<ul>
<li>更加优雅的 Reactor 模式实现、灵活的线程模型、利用 EventLoop 等创新性的机制，可以非常高效地管理成百上千的 Channel。</li>
<li>充分利用了 Java 的 Zero-Copy 机制，并且从多种角度，“斤斤计较”般的降低内存分配和回收的开销。例如，使用池化的 Direct Buffer 等技术，在提高 IO 性能的同时，减少了对象的创建和销毁；利用反射等技术直接操纵 SelectionKey，使用数组而不是 Java 容器等。</li>
<li>使用更多本地代码。例如，直接利用 JNI 调用 Open SSL 等方式，获得比 Java 内建 SSL 引擎更好的性能。</li>
<li>在通信协议、序列化等其他角度的优化。</li>
</ul>
<p>总的来说，Netty 并没有 Java 核心类库那些强烈的通用性、跨平台等各种负担，针对性能等特定目标以及 Linux 等特定环境，采取了一些极致的优化手段。</p>
<hr>
<h4 id="39、谈谈常用的分布式-ID-的设计方案？Snowflake-是否受冬令时切换影响？"><a href="#39、谈谈常用的分布式-ID-的设计方案？Snowflake-是否受冬令时切换影响？" class="headerlink" title="39、谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？"></a>39、谈谈常用的分布式 ID 的设计方案？Snowflake 是否受冬令时切换影响？</h4><p>首先，我们需要明确通常的分布式 ID 定义，基本的要求包括：</p>
<ul>
<li><strong>全局唯一</strong>，区别于单点系统的唯一，全局是要求分布式系统内唯一。</li>
<li><strong>有序性</strong>，通常都需要保证生成的 ID 是有序递增的。例如，在数据库存储等场景中，有序 ID 便于确定数据位置，往往更加高效。</li>
</ul>
<p>目前业界的方案很多，典型方案包括：</p>
<ul>
<li>基于数据库自增序列的实现。这种方式优缺点都非常明显，好处是简单易用，但是在扩展性和可靠性等方面存在局限性。</li>
<li>基于 Twitter 早期开源的Snowflake的实现，以及相关改动方案。这是目前应用相对比较广泛的一种方式，其结构定义你可以参考下面的示意图。</li>
</ul>
<p><img src="https://image.luziyangde.cn//img/ffd41494a39ef737b3c1151929c3c4ad.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/ffd41494a39ef737b3c1151929c3c4ad.png" srcset="img/loadingImage.png" alt="img"></p>
<p>整体长度通常是 64 （1 + 41 + 10+ 12 &#x3D; 64）位，适合使用 Java 语言中的 long 类型来存储。</p>
<p>头部是 1 位的正负标识位。</p>
<p>紧跟着的高位部分包含 41 位时间戳，通常使用 System.currentTimeMillis()。</p>
<p>后面是 10 位的 WorkerID，标准定义是 5 位数据中心 + 5 位机器 ID，组成了机器编号，以区分不同的集群节点。</p>
<p>最后的 12 位就是单位毫秒内可生成的序列号数目的理论极限。</p>
<p>Snowflake 的官方版本是基于 Scala 语言，Java 等其他语言的参考实现有很多，是一种非常简单实用的方式，具体位数的定义是可以根据分布式系统的真实场景进行修改的，并不一定要严格按照示意图中的设计。</p>
<ul>
<li>Redis、ZooKeeper、MongoDB 等中间件，也都有各种唯一 ID 解决方案。其中一些设计也可以算作是 Snowflake 方案的变种。例如，MongoDB 的ObjectId提供了一个 12 byte（96 位）的 ID 定义，其中 32 位用于记录以秒为单位的时间，机器 ID 则为 24 位，16 位用作进程 ID，24 位随机起始的计数序列。</li>
<li>国内的一些大厂开源了其自身的部分分布式 ID 实现，InfoQ 就曾经介绍过微信的seqsvr，它采取了相对复杂的两层架构，并根据社交应用的数据特点进行了针对性设计，具体请参考相关代码实现。另外，百度、美团等也都有开源或者分享了不同的分布式 ID 实现，都可以进行参考。</li>
</ul>
<p>关于第二个问题，Snowflake 是否受冬令时切换影响？</p>
<p>我认为没有影响，你可以从 Snowflake 的具体算法实现寻找答案。我们知道 Snowflake 算法的 Java 实现，大都是依赖于 System.currentTimeMillis()，这个数值代表什么呢？从 Javadoc 可以看出，它是返回当前时间和 1970 年 1 月 1 号 UTC 时间相差的毫秒数，这个数值与夏 &#x2F; 冬令时并没有关系，所以并不受其影响。</p>

    </div>
    
    <div class="post__license">
        <p>
            <strong>本文作者：</strong>ZYang
        </p>
        <p>
            <strong>
                本文链接：
            </strong>
            <a href="https://luziyangde.cn/2021/03/10/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">https://luziyangde.cn/2021/03/10/Java%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</a>
        </p>
        
            <strong>
                <p>文章默认使用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议进行许可，使用时请注意遵守协议。</p>

            </strong>
        
    </div>
 
    <div class="post-footer__meta"><p>更新于 2022-12-04 11:23</p></div> 
    <div class="post-entry__tags"><a href="/tags/java/" class="post-tags__link button"># java</a><a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="post-tags__link button"># 面试题</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2021/03/11/%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E5%85%AD%EF%BC%89%E3%80%90DockerFile%E3%80%91/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            上一篇
                        </div>
                        <div class="nav__title">
                            小鲸鱼历险记（六）【DockerFile】
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2021/03/09/%E4%B8%BA%E5%95%A5%E8%A6%81%E9%87%8D%E5%86%99hashCode%E5%92%8Cequals%E6%96%B9%E6%B3%95%EF%BC%9F/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            下一篇
                        </div>
                        <div class="nav__title">
                            为啥要重写hashCode和equals方法？
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2020&nbsp;-&nbsp;2022 <a href="/">ZYang&#39;s Blog</a>
        </p>
    
    
        
            <p><a href="https://beian.miit.gov.cn/"  target="_blank">陕ICP备2020014327号-1</a></p>

        
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazy",
            threshold: 0
        };
    </script>
 

 

 

 
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement('script');
            hm.src = 'https://hm.baidu.com/hm.js?114733087574c33d0c1369375e45ba99';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
 

 



 



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 

 




    </body>
</html>
