<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
        <link rel="shortcut icon" href="/img/favicon.ico">
    
    
        <link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png">
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png">
    
    
        <link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon.png">
    
    


    <!-- meta -->


<title>深入理解HashMap的底层原理 | ZYang&#39;s Blog</title>


    <meta name="keywords" content="HashMap, 源码分析, 博客,blog,Java">




    <!-- OpenGraph -->
 
    <meta name="description" content="基本概念HashMap类主要用来处理具有键值对特征的数据。随着JDK版本的更新，JDK 1.8 对HashMap底层进行了优化。 HashMap是基于哈希表对Map接口的实现，HashMap具有较快的访问速度，但是遍历顺序却是不确定的。  HashMap提供所有可选的映射操作，并允许使用 null值 和 null键。 new HashMap&lt;&gt;().put(null, null);">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解HashMap的底层原理">
<meta property="og:url" content="https://luziyangde.cn/2021/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="ZYang&#39;s Blog">
<meta property="og:description" content="基本概念HashMap类主要用来处理具有键值对特征的数据。随着JDK版本的更新，JDK 1.8 对HashMap底层进行了优化。 HashMap是基于哈希表对Map接口的实现，HashMap具有较快的访问速度，但是遍历顺序却是不确定的。  HashMap提供所有可选的映射操作，并允许使用 null值 和 null键。 new HashMap&lt;&gt;().put(null, null);">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309155755.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309161347.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309161957.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309164553.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309165704.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309165502.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309170639.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309170948.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309173010.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210309173808.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210310094202.png">
<meta property="og:image" content="https://image.luziyangde.cn//img/20210310105313.png">
<meta property="article:published_time" content="2021-03-09T06:50:00.000Z">
<meta property="article:modified_time" content="2022-12-04T03:23:00.000Z">
<meta property="article:author" content="ZYang">
<meta property="article:tag" content="HashMap">
<meta property="article:tag" content="源码分析">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://image.luziyangde.cn//img/20210309155755.png">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
    
        <link rel="stylesheet" id="hl-default-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/atom-one-light.min.css" media="none" >
        
            <link rel="stylesheet" id="hl-dark-theme" href="https://cdn.jsdelivr.net/npm/highlight.js@10.1.2/styles/atom-one-dark.min.css" media="none">
        
    

    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 6.3.0"></head>

    <body>
        <div id="app" tabindex="-1">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">ZYang&#39;s Blog</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/archives/" class="navbar-menu button">归档</a>
                
            </div>
        
        
        
    <a href="/search/" id="btn-search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="24" height="24" fill="currentColor" stroke="currentColor" stroke-width="32"><path d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z"></path></svg>
    </a>


        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/archives/" class="dropdown-menu button">归档</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        深入理解HashMap的底层原理
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2021/03/" class="post-meta__date button">2021-03-09 14:50</a>
        
 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E7%9F%A5%E5%AD%97%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">必知字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE"><span class="toc-number">4.</span> <span class="toc-text">面试常问</span></a></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">文章目录</div>
        <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%85%E7%9F%A5%E5%AD%97%E6%AE%B5"><span class="toc-number">2.</span> <span class="toc-text">必知字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%B8%B8%E9%97%AE"><span class="toc-number">4.</span> <span class="toc-text">面试常问</span></a></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header">
    <div class="post__expire" id="post-expired-notify">
        <p>
            本文最后更新于 &lt;span id=&#34;expire-date&#34;&gt;&lt;/span&gt; 天前，文中部分描述可能已经过时。
        </p>
    </div>
    <script>
        (() => {
            var update = Date.parse("2022-12-04"),
                date = new Date(),
                now = date.getTime(),
                expire = now - update,
                expire_days = Math.floor(expire/(24*3600*1000));
            if (expire_days >= 120) {
                document.querySelectorAll('#expire-date')[0].innerHTML = expire_days;
                document.querySelectorAll('#post-expired-notify')[0].style.display = 'block';
            }
        })();
    </script>
</div>
    <div class="post__content">
        <hr>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>HashMap类主要用来处理具有<strong>键值对</strong>特征的数据。随着JDK版本的更新，JDK 1.8 对HashMap底层进行了优化。</p>
<p>HashMap是基于哈希表对Map接口的实现，HashMap具有较快的访问速度，但是遍历顺序却是不确定的。</p>
<p><img src="https://image.luziyangde.cn//img/20210309155755.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309155755.png" srcset="img/loadingImage.png"></p>
<p>HashMap提供<strong>所有</strong>可选的映射操作，并允许使用 <strong>null值</strong> 和 <strong>null键</strong>。</p>
<pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;().put(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);</code></pre>

<p>Hash并非线程安全，当存在多个线程同时写入HashMap时，可能会导致数据的不一致。</p>
<hr>
<h4 id="必知字段"><a href="#必知字段" class="headerlink" title="必知字段"></a>必知字段</h4><p><img src="https://image.luziyangde.cn//img/20210309161347.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309161347.png" srcset="img/loadingImage.png"></p>
<p><img src="https://image.luziyangde.cn//img/20210309161957.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309161957.png" srcset="img/loadingImage.png"></p>
<ul>
<li><code>loadFactor</code> 称为负载因子，默认值为0.75</li>
<li><code>threshold</code> 表示所能容纳的键值对的临界值</li>
<li><code>threshold</code> 计算公式为：数组长 * 负载因子</li>
<li><code>size</code> 是HashMap中实际存在的键值对数量</li>
<li><code>modCount</code> 字段用来记录HashMap内部结构发生变化的次数</li>
<li>HashMap的默认容量 <code>INITIAL_CAPACITY</code> 为16</li>
</ul>
<pre><code class="hljs java"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The initial capacity -- MUST be a power of two.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;</code></pre>

<pre><code class="hljs java"><span class="hljs-comment">/* ---------------- Fields -------------- */</span>

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The table, initialized on first use, and resized as</span>
<span class="hljs-comment"> * necessary. When allocated, length is always a power of two.</span>
<span class="hljs-comment"> * (We also tolerate length zero in some operations to allow</span>
<span class="hljs-comment"> * bootstrapping mechanics that are currently not needed.)</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span>
<span class="hljs-comment"> * for keySet() and values().</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The number of key-value mappings contained in this map.</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The number of times this HashMap has been structurally modified</span>
<span class="hljs-comment"> * Structural modifications are those that change the number of mappings in</span>
<span class="hljs-comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span>
<span class="hljs-comment"> * rehash).  This field is used to make iterators on Collection-views of</span>
<span class="hljs-comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The next size value at which to resize (capacity * load factor).</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-comment">// (The javadoc description is true upon serialization.</span>
<span class="hljs-comment">// Additionally, if the table array has not been allocated, this</span>
<span class="hljs-comment">// field holds the initial array capacity, or zero signifying</span>
<span class="hljs-comment">// DEFAULT_INITIAL_CAPACITY.)</span>
<span class="hljs-type">int</span> threshold;

<span class="hljs-comment">/**</span>
<span class="hljs-comment"> * The load factor for the hash table.</span>
<span class="hljs-comment"> *</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@serial</span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;</code></pre>

<hr>
<h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>在JDK 1.8 中，HashMap 采用了<strong>数组 + 链表 + 红黑树</strong>的存储结构。</p>
<p><img src="https://image.luziyangde.cn//img/20210309164553.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309164553.png" srcset="img/loadingImage.png"></p>
<p>HashMap数组部分称为<strong>哈希桶</strong>，当链表长度大于等于&#96;&#96; <strong>8</strong> 时，链表数据将以 <strong>红黑树</strong> 的形式进行存储，当长度降到 <strong>6</strong> 时，转为 <strong>链表</strong>。</p>
<ul>
<li>链表的时间复杂度为O(n)；</li>
<li>红黑树的时间复杂度为O(logn)；</li>
</ul>
<p><img src="https://image.luziyangde.cn//img/20210309165704.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309165704.png" srcset="img/loadingImage.png"></p>
<p>每个Node节点存储着用来定位数据索引位置的hash值，k键，v值以及指向链表下一个节点的 <code>Node&lt;K, V&gt; next</code> 节点组成。</p>
<p>Node 是 HashMap的内部类，实现了Map.Entry接口，本质是一个键值对。</p>
<p><img src="https://image.luziyangde.cn//img/20210309165502.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309165502.png" srcset="img/loadingImage.png"></p>
<pre><code class="hljs java"> <span class="hljs-comment">/**</span>
<span class="hljs-comment"> * Basic hash bin node, used for most entries.  (See below for</span>
<span class="hljs-comment"> * TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span>
<span class="hljs-comment"> */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;
	<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;
	<span class="hljs-keyword">final</span> K key;
	V value;
	Node&lt;K,V&gt; next;</code></pre>

<p>当向 HashMap 中<strong>插入</strong>数据时，首先要确定在哈希桶中的位置，那么如何确定Node的存储位置呢？</p>
<p><img src="https://image.luziyangde.cn//img/20210309170639.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309170639.png" srcset="img/loadingImage.png"></p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;
	<span class="hljs-type">int</span> h;
	<span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
&#125;</code></pre>

<p>以添加key键为字符 ‘e’ 为例：</p>
<p>HashMap首先调用 <code>hashCode()</code> 方法，获取键key的hashCode值 h(101)，然后对其进行<strong>高位运算</strong>：</p>
<p>将 h <strong>右移</strong>16位以取得h的 高16位，与原 h 的 低16位 进行<strong>异或</strong>运算（结果为 101）</p>
<p>最后将得到的 h值 与（table.length - 1）进行<strong>与运算</strong>获得该对象的 保留位 以计算下标。</p>
<p><img src="https://image.luziyangde.cn//img/20210309170948.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309170948.png" srcset="img/loadingImage.png"></p>
<hr>
<pre><code class="hljs java">HashMap&lt;Character, Integer&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();
hashMap.put(K, V);</code></pre>

<p>例如存放键key分别为 ‘a’, ‘b’, ‘c’, ‘d’, ‘r’, ‘t’, ‘e’, ‘a’, ‘g’, ‘i’ 对象，</p>
<p>通过计算知：</p>
<ul>
<li>‘a’ 的下标为 1(0001)</li>
<li>‘b’ 为 2(0010),</li>
<li>‘d’ 为 4(0100),</li>
<li>‘r’ 为 2(0010),</li>
<li>‘t’ 为 4(0100),</li>
<li>‘e’ 为 5(0101)</li>
</ul>
<p>当HashMap调用 put() 方法插入键为字符的对象时：</p>
<p><img src="https://image.luziyangde.cn//img/20210309173010.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309173010.png" srcset="img/loadingImage.png"></p>
<p>HashMap键的输出顺序为：a, b, r, d, t, e, g, i</p>
<p>当插入第二个以’a’为key的对象时，将新值赋值给’a’的值；</p>
<p>当插入的对象大小超过临界值时，HashMap将新建一个桶数组，并重新赋值（jdk1.7 和 jdk1.8 重新赋值方式略有不同）</p>
<p><img src="https://image.luziyangde.cn//img/20210309173808.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210309173808.png" srcset="img/loadingImage.png"></p>
<p>HashMap键的输出顺序为：null, a, b, d, e, f, g, i, j, k, r, t, u, w</p>
<hr>
<h4 id="面试常问"><a href="#面试常问" class="headerlink" title="面试常问"></a>面试常问</h4><p><strong>面试官</strong>：在日常开发中，JDK 中包含的集合几乎我们每天都会用到，那么你可以简单地说一下Java的集合容器包含了哪些吗？【Java集合容器包含了哪些？】</p>
<p><strong>答</strong>：主要是三个接口：List、Set、Map，以及实现了这些接口的诸多子类。</p>
<p><strong>面试官</strong>：那他们三个都是对Collection接口的实现吗？</p>
<p><strong>答</strong>：不是的，List、Set是实现了Collection接口，Map是单独的接口，只不过当我们在谈到这个JDK的容器的时候，经常会把这三者放在一起谈。</p>
<p><strong>面试官</strong>：你能简单说说这三者在概念上的差别吗？【List、Set、Map的基本区别】</p>
<p><strong>答</strong>：List是有序的，这个有序指的是插入元素的顺序，其中呢可以存放重复的值和null值；Set呢它是无序的，其中的值是各不相同的，所以呢它里面只能存放一个null值；Map呢它存放的是Entry键值对，键呢必须是唯一的，所以说在Map里面只能存放一个键为null的值，但是可以存放多个值为null的Entry。</p>
<p><strong>面试官</strong>：在Map中最常用的要数HashMap，关于HashMap，你能说说你的理解吗？【HashMap的基本概念】</p>
<p><strong>答</strong>：关于HashMap，正如它的名字那样，它的key是通过hashCode来进行存储的，这又要谈到它的内部结构了，HashMap内部的数据结构呢主要用到了三种，一种就是数组，然后是链表，以及在JDK8中为了提升它的查询速度呢，加入的红黑树结构。</p>
<p><strong>面试官</strong>：你可以具体的讲一下吗？</p>
<p><strong>答</strong>：可以看我画的这张图更加直观一些。我来介绍一下HashMap中的数据结构，首先呢HashMap维护了一个数组，数组中存储的元素类型为Entry，Entry就是键值对，当每一个Entry要被添加到Map中时，首先要使用Hash算法来计算它的hashCode【计算的是key的hashCode】，然后对hashCode进行取模操作，比如entryA取到的模是1，entryB取到的是0，entryC取到的是3，那么根据这个值来添加到对应的数组中的位置，这样呢就不难发现，添加的过程中hash算法是比较重要的，加入一个Hash算法比较优秀的话呢，它计算出来的hashCode是比较分散比较均匀的，所以每一个元素都能均匀地分布在数组中，这样的呢，就认为这个hash算法是优秀的，然后它的查找时间复杂度就是O(1)，如果这个Hash算法比较差呢，那么它可能计算出来的hashCode取模的结果都是一样的，那么整个数组就会退化成一个链表，那么它的查询速度就会变成O(n)，这样的话它们的查询效率差异将会是非常大的。JDK 1.8 中对此做了一些优化，就是说当一个数组的节点上挂载的node的数值超过8时，就将这个链表转化成红黑树，那红黑树的查询速度是O(logn)，这样呢就起到了一定的优化作用。</p>
<p><strong>面试官</strong>：那为什么这个临界值设置为8呢？</p>
<p><strong>答</strong>：至于这个临界值为什么是8呢，这个是和<strong>泊松分布</strong>有关的，为什么这么设计呢？这也是类库的开发者在性能和空间开销上的一个取舍。</p>
<p><strong>面试官</strong>：看过具体的源码吗？说说它的实现方式吧。【HashMap中的元素Node的源码分析】</p>
<p><strong>答</strong>：之前提到了HashMap的数据结构是 数组 + 链表，其中数组中存储的元素叫Node，那么我们就来说一下Node吧！</p>
<p>Node是对Entry的一个实现，Entry是一个接口，Node是它的一个实现类，那我们接下来再看一下Node的源码！</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K,V&gt; &#123;
	<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;
	<span class="hljs-keyword">final</span> K key;
	V value;
	Node&lt;K,V&gt; next;

	Node(<span class="hljs-type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;
		<span class="hljs-built_in">this</span>.hash = hash;
		<span class="hljs-built_in">this</span>.key = key;
		<span class="hljs-built_in">this</span>.value = value;
		<span class="hljs-built_in">this</span>.next = next;
	&#125;

	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span>        &#123; <span class="hljs-keyword">return</span> key; &#125;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span>      &#123; <span class="hljs-keyword">return</span> value; &#125;
	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;

	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;
		<span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);
	&#125;

	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">setValue</span><span class="hljs-params">(V newValue)</span> &#123;
		<span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;
		value = newValue;
		<span class="hljs-keyword">return</span> oldValue;
	&#125;

	<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;
		<span class="hljs-keyword">if</span> (o == <span class="hljs-built_in">this</span>)
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Map.Entry) &#123;
			Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
			<span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;
				Objects.equals(value, e.getValue()))
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		&#125;
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	&#125;
&#125;</code></pre>

<p>那我们可以看到 Node实现了 Entry这个接口，再来看看它的属性值，一个是hash，hash就是记录它的hash值，除了key和value呢，还有一个next，next就指向这个node的下一个节点，因为它的可以被拓展成一个链表的，接下来呢我们再看看它的方法，除了getter、setter方法，我们可以看到Node重写了Object的hashCode和equals方法。</p>
<p>明白了Node的构成之后呢，我们再来看一下HashMap的成员属性。</p>
<pre><code class="hljs java"><span class="hljs-comment">/* ---------------- Fields -------------- */</span>

    <span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;

    <span class="hljs-keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;

    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;

    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;

    <span class="hljs-type">int</span> threshold;

    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;</code></pre>

<p>从它的源码可以来看一看，除了我们之前提到的 <code>table</code>，它是一个node数组之外呢，还有 <code>entrySet</code>，<code>size</code>，<code>modCount</code>，<code>threshold</code>，<code>loadFactor</code> 这几个属性。</p>
<p>一一来解释下，可以看到这个Set的泛型是 Map.Entry，它是Node的一个上层接口，主要存放Map中所有的Entry，便于用来进行遍历等操作；</p>
<p>size 是 table 中被使用的实际元素的数量；</p>
<p>modCount 是一个计数器，它主要用来记录HashMap结构发生变化的次数，比如put了一个新的key，发生了扩容等等；</p>
<p>threshold &#x3D; size * loadFactor；</p>
<p>loadFactor 是负载因子，在下面扩容机制的时候会详细介绍这个属性的作用。默认值它是 0.75。</p>
<p><strong>面试官</strong>：不好意思，打断一下，transient 这个修饰符不是很常见，你能介绍一下它的作用吗？【<strong>笔记5：transient修饰符的作用</strong>】</p>
<p><strong>答</strong>：transient 到底是干什么用的呢，是这样子的，Java中有个Serilizable 接口，就是当一个类实现了这个接口之后，它就能进行自动序列化，那么什么是自动的序列化呢？就是说Java进程之间在进行对象传输的时候，或者说对对象进行持久化等操作的时候呢，就要将这个对象序列化成二进制流，然后便于传输或者进行存储。那transient 修饰了一个属性之后呢，该属性将不会被自动序列化，比如一些敏感的字段，类库开发者是不希望它被序列化的。</p>
<pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> b;</code></pre>

<p>比如说有一个对象它有一个private的属性int是a，然后它还有一个transient的int类型的属性b，那么它序列化之后保存到本地文件上，之后再进行序列化成对象的时候，这个属性b将会消失，因为它是不可见的。</p>
<p><strong>面试官</strong>：好的，你说的没错，那么接下来我们再回归正题吧，我们知道table是一个数组，数组是在初始化指定长度的，无法动态扩展，但是呢在实际业务中我们往往无法预测它的未来长度，那么这点HashMap是如何解决的呢？【<strong>笔记6：核心重点：HashMap扩容机制</strong>】</p>
<p><strong>答</strong>：接下来我就结合上述几个属性来介绍一下HashMap比较核心的扩容机制吧，首先谈谈扩容的时机，就是HashMap在什么情况下才会扩容。</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;</code></pre>

<p>从源码中这两行我们可以得知，HashMap默认初始化长度是16，它的默认负载因子是0.75，那么负载因子是用来干嘛的呢？</p>
<p>当table中的元素被使用到了75%以上的时候呢，将会进行扩容，那么threshold指的就是这样一个临界值，它等于 size * loadFactor。</p>
<p>当table中元素个数达到这个threshold 之后将会进行扩容，每次扩容都是成倍的，即扩容之后table大小是之前的两倍，扩容属于一个比较消耗资源的操作，它需要为数组分配更多的空间。但是呢，它的好处就是说，因为你的数组更长了，所以hash算法的结果能够更均匀，它的碰撞也会更少，那么个数与碰撞的几率是服从泊松分布的，就是发现在0.75处碰撞的几率是最小的，所以使用0.75作为默认的负载因子。当然，如果面临特殊的业务情况下，开发者是可以手动控制负载因子的，HashMap也提供了相应的构造器。</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">HashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity, <span class="hljs-type">float</span> loadFactor)</span> &#123;
	<span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> +
										   initialCapacity);
	<span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)
		initialCapacity = MAXIMUM_CAPACITY;
	<span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))
		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> +
										   loadFactor);
	<span class="hljs-built_in">this</span>.loadFactor = loadFactor;
	<span class="hljs-built_in">this</span>.threshold = tableSizeFor(initialCapacity);
&#125;</code></pre>

<p><strong>面试官</strong>：那么你能谈一谈负载因子的默认值为什么是0.75，而它扩容的时候又是成倍增加的呢？你能去揣测一下开发者他为什么这么设计吗？【<strong>笔记7：为什么HashMap扩容，每次长度都是 * 2</strong>】</p>
<p><strong>答</strong>：至于为什么table的长度一定是2的次幂，是为了在取模的时候做优化，当判断一个元素进入哪一个桶的时候，需要对key的hash值进行取模（%），但是 <code>%</code> 是一个比较重的操作，它比较耗性能，而当数组的长度总是2的n次方时，<code>h &amp; (length - 1) </code> 运算等价于对 length 取模（下面会讲到），相较于 <code>%</code>，<code>&amp;</code> 操作性能更好。</p>
<p>为什么呢？因为它是位运算操作，直接对二进制数据计算，而 <code>%</code> 需要将hash值转化为十进制后再计算。所以 <code>&amp;</code> 在性能上有很大优势，可以看一下下面两段代码：</p>
<pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;
	<span class="hljs-type">int</span> h;
	<span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);
&#125;</code></pre>

<pre><code class="hljs java">...
Node&lt;K,V&gt; e;
<span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;
	oldTab[j] = <span class="hljs-literal">null</span>;
	<span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)
		newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;
                ...</code></pre>

<p>可以看到，Node中的hash属性都是通过上面的hash函数计算出来的，那么为什么在计算key的hash值的时候，为什么要将key的hash值右移16位，然后再进行异或操作？</p>
<p>这其实也是HashMap设计中的一个细节，在扩容时，将旧 old table 中的元素添加到 new table 时，使用了 <code>newTab[e.hash &amp; (newCap - 1)] = e;</code>  这样的操作.</p>
<p><strong>面试官</strong>：上面你聊到了hash算法的源码，那么能介绍一下，为什么HashMap要在Object的hashCode的基础上，进行异或和右移的操作呢 <code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</code> ，这样有什么好处？【笔记8：在取模之前，进行右移和异或的好处】</p>
<p><strong>答</strong>：将key的hash值无符号右移16位，然后再与旧值进行异或操作，主要是为了保留高位和低位的信息，这样就能够表现目标值的特征，这样能够减少碰撞。</p>
<p>假如A的值是 11101110，当它与 111 进行 <code>&amp;</code> 运算的时候，它的高四位的信息将会全部丢失，因为 <code>&amp;</code> 111 的高四位全都是0，所以得出的结果就是 110。</p>
<pre><code class="hljs java">A <span class="hljs-number">11101110</span>  &amp; <span class="hljs-number">00000111</span> （<span class="hljs-number">111</span>）= <span class="hljs-number">00000110</span> （<span class="hljs-number">110</span>）
^ <span class="hljs-number">00001110</span>
   <span class="hljs-number">11100000</span>  &amp; <span class="hljs-number">00000111</span> （<span class="hljs-number">111</span>）=  <span class="hljs-number">00000000</span>（<span class="hljs-number">000</span>）
</code></pre>

<blockquote>
<p>异或（^）相同取0，不同取1<br>&amp;：全1才1</p>
</blockquote>
<pre><code class="hljs java">System.out.println(Integer.toBinaryString(<span class="hljs-number">0b00001110</span> ^ 
<span class="hljs-number">0b11100000</span>));</code></pre>

<p><img src="https://image.luziyangde.cn//img/20210310094202.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210310094202.png" srcset="img/loadingImage.png"></p>
<p>那么我们首先对 A 进行右移四位的操作之后呢，将会得到 00001110 这个值，然后再将旧的值和新的值进行异或操作之后呢，将会得到 11101110，再用这个值与 (length - 1) 进行<code>&amp;</code> 操作之后呢，我们会发现得到了一个不一样的结果：00000000，这个结果作为A的模就更加具有代表性，因为它混合了A的高四位和低四位之间的信息。</p>
<p><strong>面试官</strong>：那你能解释下为什么“当数组的length总是2的n次方时，h &amp; (length - 1)运算等价于对length取模”呢？【笔记9：为什么 h % length &#x3D;&#x3D; h &amp; (length - 1)】</p>
<p><strong>答</strong>：为什么length对hash值取模的结果和 hash值对(length - 1) 做 <code>&amp;</code> 之后的结果是一样的呢，那首先我们需要知道一个概念，对无符号数取模和取余是一样的，设length 为 2^n，那么hash值对2^n取余，就是将x的二进制表示右移n位，结果就是商，移动的n位则是余数，当 length 为 2^n，则 2 ^(n - 1) 的二进制表示等于 n 个 1，与之做与操作，结果是一样的。</p>
<p>我们假设这个hash值是：1101 1101（221），10（2），可以计算得出它的取模结果是 1。</p>
<pre><code class="hljs java">      <span class="hljs-number">1101</span> <span class="hljs-number">1101</span>（<span class="hljs-number">221</span>） % <span class="hljs-number">10</span>（<span class="hljs-number">2</span>）= <span class="hljs-number">1</span>

&gt;&gt;<span class="hljs-number">2</span> <span class="hljs-number">0011</span> <span class="hljs-number">0111</span> --&gt; <span class="hljs-number">01</span>（<span class="hljs-number">1</span>）</code></pre>

<p>我们将这个hash值的二进制表示右移n位，移动的其实就是最后两位 01（1），01就是余数，01的十进制表示就是1，这和我们刚才计算得出的1是一致的。</p>
<p>那么我们在用hash对(length - 1)进行&amp;操作：10 - 1 其实就是十进制的 2- 1，得出的二进制结果是01，那么我们对 11011101 与 01 做 &amp; 操作，得出的结果也是01，那么它的十进制表示也是1。</p>
<p><strong>面试官</strong>：那么接下来你可以说一下，一个元素put的整个流程吗？【<strong>笔记10：put操作的流程</strong>】</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;
	<span class="hljs-keyword">return</span> putVal(hash(key), key, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);
&#125;


<span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent,</span>
<span class="hljs-params">			   <span class="hljs-type">boolean</span> evict)</span> &#123;
	Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-type">int</span> n, i;
	<span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)
		n = (tab = resize()).length;
	<span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>)
		tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);
	<span class="hljs-keyword">else</span> &#123;
		Node&lt;K,V&gt; e; K k;
		<span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;
			((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
			e = p;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)
			e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-built_in">this</span>, tab, hash, key, value);
		<span class="hljs-keyword">else</span> &#123;
			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">binCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; ; ++binCount) &#123;
				<span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;
					p.next = newNode(hash, key, value, <span class="hljs-literal">null</span>);
					<span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>
						treeifyBin(tab, hash);
					<span class="hljs-keyword">break</span>;
				&#125;
				<span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;
					((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.equals(k))))
					<span class="hljs-keyword">break</span>;
				p = e;
			&#125;
		&#125;
		<span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>
			<span class="hljs-type">V</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> e.value;
			<span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)
				e.value = value;
			afterNodeAccess(e);
			<span class="hljs-keyword">return</span> oldValue;
		&#125;
	&#125;
	++modCount;
	<span class="hljs-keyword">if</span> (++size &gt; threshold)
		resize();
	afterNodeInsertion(evict);
	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
&#125;</code></pre>

<p><img src="https://image.luziyangde.cn//img/20210310105313.png" class="lazy" data-srcset="https://image.luziyangde.cn//img/20210310105313.png" srcset="img/loadingImage.png"></p>
<p>在这张图中最重要的是我们需要知道如果table为空，或是length为0，那么HashTable将会扩容，其他的情况实在插入之后再进行扩容。</p>
<p><strong>面试官</strong>：那么关于HashMap的最后一个重点，可以介绍一下它的线程安全情况吗？【笔记11：HashMap线程不安全】</p>
<p><strong>答</strong>：首先先说结论：HashMap不是线程安全的，因为我们看它的源码可以知道，它的很多操作都不是使用 <code>synchronized</code> 来进行同步的。</p>
<pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCapacity)</span> &#123;
	Entry&lt;K,V&gt;[] oldTable = getTable();
	<span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> oldTable.length;
	<span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;
		threshold = Integer.MAX_VALUE;
		<span class="hljs-keyword">return</span>;
	&#125;

	Entry&lt;K,V&gt;[] newTable = newTable(newCapacity);
	transfer(oldTable, newTable);
	table = newTable;

	<span class="hljs-keyword">if</span> (size &gt;= threshold / <span class="hljs-number">2</span>) &#123;
		threshold = (<span class="hljs-type">int</span>)(newCapacity * loadFactor);
	&#125; <span class="hljs-keyword">else</span> &#123;
		expungeStaleEntries();
		transfer(newTable, oldTable);
		table = oldTable;
	&#125;
&#125;</code></pre>

<p>首先呢我们来看它的resize这个源码，resize逻辑很简单，其实就是将旧数组中的元素通过转换之后将其填充到新数组之中，那么关键就是这个transfer这个函数方法.</p>
<pre><code class="hljs java"><span class="hljs-comment">/** Transfers all entries from src to dest tables */</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest)</span> &#123;
	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; src.length; ++j) &#123;
		Entry&lt;K,V&gt; e = src[j];
		src[j] = <span class="hljs-literal">null</span>;
		<span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>) &#123;
			Entry&lt;K,V&gt; next = e.next;
			<span class="hljs-type">Object</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> e.get();
			<span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;
				e.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Help GC</span>
				e.value = <span class="hljs-literal">null</span>; <span class="hljs-comment">//  &quot;   &quot;</span>
				size--;
			&#125; <span class="hljs-keyword">else</span> &#123;
				<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> indexFor(e.hash, dest.length);
				e.next = dest[i];
				dest[i] = e;
			&#125;
			e = next;
		&#125;
	&#125;
&#125;</code></pre>

<p>刚才也提到了transfer函数主要是将旧数组中的元素填充到新数组中去，那么我们这边假设一个旧数组的长度是2，它扩容之后的数组长度是4。</p>
<p>HashMap在扩容的时候是如何产生线程安全问题的，假设我们有两个线程thread1和thread2，首先我们需要明确几个概念，newTable这些变量都是在当前线程栈中的，所以它是跟线程无关的，它是线程独立的，但是node这些节点是在堆内存中分配的，不同的线程是可以对它进行操作，那么就会存在线程同步问题。</p>
<blockquote>
<p>JDK 1.7中是 <strong>头插法</strong></p>
</blockquote>

    </div>
    
    <div class="post__license">
        <p>
            <strong>本文作者：</strong>ZYang
        </p>
        <p>
            <strong>
                本文链接：
            </strong>
            <a href="https://luziyangde.cn/2021/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">https://luziyangde.cn/2021/03/09/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</a>
        </p>
        
            <strong>
                <p>文章默认使用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 协议进行许可，使用时请注意遵守协议。</p>

            </strong>
        
    </div>
 
    <div class="post-footer__meta"><p>更新于 2022-12-04 11:23</p></div> 
    <div class="post-entry__tags"><a href="/tags/HashMap/" class="post-tags__link button"># HashMap</a><a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="post-tags__link button"># 源码分析</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2021/03/09/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            上一篇
                        </div>
                        <div class="nav__title">
                            十大排序算法
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2021/03/06/%E5%B0%8F%E9%B2%B8%E9%B1%BC%E5%8E%86%E9%99%A9%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89%E3%80%90%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7%E3%80%91/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            下一篇
                        </div>
                        <div class="nav__title">
                            小鲸鱼历险记（五）【容器数据卷】
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="回到顶部" title="回到顶部">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2020&nbsp;-&nbsp;2022 <a href="/">ZYang&#39;s Blog</a>
        </p>
    
    
        
            <p><a href="https://beian.miit.gov.cn/"  target="_blank">陕ICP备2020014327号-1</a></p>

        
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
        
    <script defer src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.1.0/dist/lazyload.min.js"></script>
    <script>
        window.lazyLoadOptions = {
            elements_selector: ".lazy",
            threshold: 0
        };
    </script>
 

 

 

 
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement('script');
            hm.src = 'https://hm.baidu.com/hm.js?114733087574c33d0c1369375e45ba99';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>
 

 



 



 


    
 


    
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>

    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.css">

    
<script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.4.1/dist/jquery.fancybox.min.js"></script>

    <script>
        let lazyloadT = Boolean('true'),
            auto_fancybox = Boolean('true')
        if (auto_fancybox) {
            $(".post__content").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        } else {
            $(".post__content").find("fancybox").find('img').each(function () {
                var element = document.createElement("a");
                $(element).attr("data-fancybox", "gallery");
                $(element).attr("href", $(this).attr("src"));
                if (lazyloadT) {
                    $(element).attr("href", $(this).attr("data-srcset"));
                }
                $(this).wrap(element);
            });
        }
    </script>
 

 

 

 

 




    </body>
</html>
